{"version":3,"sources":["../src/access.js"],"names":["_vnodeFromCx","cx","node","vnode","children","$node","ensureDoc","bind","values","type","inode","depth","idx","firstChild","next","first","_nextOrPrev","dir","parent","sib","indexInParent","nextSibling","previousSibling","getDoc","lastChild","last","count","arguments","length","Axis","self","f","name","isVNode","n","__is_VNode","_isElement","_isAttribute","_isText","_isList","_isPI","_isComment","_isLiteral","cxFilter","iterable","v","k","i","__cx","position","size","_isEq","a","b","_nodeTest","typeTest","qnameOrKey","undefined","hasWildcard","test","regex","RegExp","replace","isTuple","key","__Accessor","__is_NodeTypeTest","element","qname","list","keyOrIndex","processingInstruction","comment","_attrGet","entries","val","attr","attribute","$qname","text","value","g","__is_Axis","__type","child","siblingsOrSelf","select","paths","boundEnsureDoc","path","_axify","skipCompare","bound","_comparer","changeFn","has","_checked","set","WeakMap","$path","at","substring","isEmptyNode","$a"],"mappings":"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","sourcesContent":["import { ensureDoc } from \"l3n\";\n\nimport { error } from \"./error\";\n\nimport { seq, isSeq, from, forEach, filter, pipe, switchMap, foldLeft } from \"./seq\";\n\nimport { isUndef } from \"./util\";\n\nconst _vnodeFromCx = (cx,node) => cx && \"vnode\" in cx ? cx.vnode : node.cx.vnode;\n\nexport function children($node) {\n\tconst cx = this;\n\treturn switchMap(ensureDoc.bind(cx)($node),node => {\n\t\tconst vnode = _vnodeFromCx(cx,node);\n\t\tconst values = node.type == 2 ? [node.inode] : node.values();\n\t\tconst depth = node.depth + 1;\n\t\treturn forEach(values,(inode, idx) => vnode(inode,node,depth,idx + 1));\n\t});\n}\n\nexport function firstChild($node) {\n\tconst cx = this;\n\t// assume ensureDoc returns the correct node\n\treturn switchMap(ensureDoc.bind(cx)($node),node => {\n\t\tconst vnode = _vnodeFromCx(cx,node);\n\t\tlet next = node.first();\n\t\treturn next ? seq(vnode(next,node,node.depth + 1, 0)) : seq();\n\t});\n}\n\nconst _nextOrPrev = (cx,$node,dir) => {\n\treturn switchMap(ensureDoc.bind(cx)($node),node => {\n\t\tconst vnode = _vnodeFromCx(cx,node);\n\t\tvar parent = node.parent;\n\t\tconst sib = parent && parent[dir > 0 ? \"next\" : \"previous\"](node);\n\t\treturn sib ? seq(vnode(sib, parent, node.depth, node.indexInParent + dir)) : seq();\n\t});\n};\n\nexport function nextSibling($node){\n\treturn _nextOrPrev(this, $node, 1);\n}\n\nexport function previousSibling($node){\n\treturn _nextOrPrev(this, $node, -1);\n}\n\nexport function getDoc($node) {\n\tvar cx = this;\n\treturn switchMap(ensureDoc.bind(cx)($node),node => {\n\t\tdo {\n\t\t\tnode = node.parent;\n\t\t} while(node.parent);\n\t\treturn seq(node);\n\t});\n}\n\nexport function lastChild($node){\n\tvar cx = this;\n\treturn switchMap(ensureDoc.bind(cx)($node),node => {\n\t\tconst last = node.last();\n\t\tconst vnode = cx.vnode || node.cx.vnode;\n\t\treturn last ? seq(vnode(last, node, node.depth, node.count() - 1)) : seq();\n\t});\n}\n\nexport function parent($node) {\n\tif(!arguments.length) return Axis(parent);\n\tvar cx = this;\n\treturn switchMap(ensureDoc.bind(cx)($node),node => seq(node.parent));\n}\n\nexport function self(f) {\n\tif(f.name !== \"forEach\" && f.name !== \"filter\") f = forEach(f);\n\treturn Axis(node => node, f, 3);\n}\n\nexport const isVNode = n => !!n && n.__is_VNode;\n\nconst _isElement = n => isVNode(n) && n.type == 1;\n\nconst _isAttribute = n => isVNode(n) && n.type == 2;\n\nconst _isText = n => isVNode(n) && n.type == 3;\n\nconst _isList = n => isVNode(n) && n.type == 5;\n\n//const _isMap = n => isVNode(n) && n.type == 6;\n\nconst _isPI = n => isVNode(n) && n.type == 7;\n\nconst _isComment = n => isVNode(n) && n.type == 8;\n\nconst _isLiteral = n => isVNode(n) && n.type == 12;\n\nexport function cxFilter(iterable,f){\n\treturn filter(iterable,function(v,k,i){\n\t\tif(!isSeq(v) && !isVNode(v)) v = seq(v);\n\t\tv.__cx = [k,i];\n\t\treturn f(v,k,i);\n\t});\n}\n\nexport const position = n => n.__cx ? n.__cx[0] + 1 : n.indexInParent;\n\nexport const last = n => n.__cx ? n.__cx[1].size : n.parent ? n.parent.size : 1;\n\nconst _isEq = (a,b) => a === b;\n\n// TODO convert qname to integer when parent is array\nfunction _nodeTest(typeTest,qnameOrKey) {\n\tvar f;\n\tif (qnameOrKey === undefined) {\n\t\tf = typeTest;\n\t} else {\n\t\tvar hasWildcard = /\\*/.test(qnameOrKey);\n\t\tif (hasWildcard) {\n\t\t\tvar regex = new RegExp(qnameOrKey.replace(/\\*/, \"(\\\\w[\\\\w0-9-_]*)\"));\n\t\t\tf = n => {\n\t\t\t\tlet isTuple = n.parent.type == 6;\n\t\t\t\tif(isTuple || n.name) {\n\t\t\t\t\treturn typeTest(n) && regex.test(isTuple ? n.key : n.name);\n\t\t\t\t}\n\t\t\t\treturn typeTest(n);\n\t\t\t};\n\t\t} else {\n\t\t\tf = n => {\n\t\t\t\tlet isTuple = n.parent.type == 6;\n\t\t\t\tif(isTuple || n.name) {\n\t\t\t\t\treturn _isEq(isTuple ? n.key : n.name,qnameOrKey) && typeTest(n);\n\t\t\t\t}\n\t\t\t\treturn typeTest(n);\n\t\t\t};\n\t\t\tf.__Accessor = qnameOrKey;\n\t\t}\n\t}\n\tf.__is_NodeTypeTest = true;\n\treturn f;\n}\n\nexport function element(qname) {\n\treturn _nodeTest(_isElement,qname);\n}\n\nexport function list(keyOrIndex) {\n\treturn _nodeTest(_isList,keyOrIndex);\n}\n\n/*export function map() {\n\treturn _nodeTest(_isMap);\n}*/\n\nexport function processingInstruction() {\n\treturn _nodeTest(_isPI);\n}\n\nexport function comment() {\n\treturn _nodeTest(_isComment);\n}\n\nfunction _attrGet(key,$node){\n\treturn switchMap($node,node => {\n\t\tvar entries;\n\t\tif (key !== null) {\n\t\t\tvar val = node.attr(key);\n\t\t\tif (!val) return [];\n\t\t\tentries = [[key, val]];\n\t\t} else {\n\t\t\tentries = node.entries();\n\t\t}\n\t\treturn forEach(from(entries),function ([k,v]) {\n\t\t\treturn node.vnode(node.attr(k, v), node.parent, node.depth + 1, node.indexInParent);\n\t\t});\n\t});\n}\n\n// TODO make axis default, process node here, return seq(VNodeIterator)\n// TODO maybe have Axis receive post-process func/seq\nexport function attribute($qname) {\n\tif(isUndef($qname)) $qname = \"*\";\n\treturn switchMap($qname,qname => {\n\t\tvar hasWildcard = /\\*/.test(qname);\n\t\t// getter of attributes / pre-processor of attributes\n\t\t// TODO iterator!\n\t\t// filter of attributes\n\t\tvar f;\n\t\tif (hasWildcard) {\n\t\t\tvar regex = new RegExp(qname.replace(/\\*/, \"(\\\\w[\\\\w0-9-_]*)\"));\n\t\t\t//\tattrEntries returns tuples\n\t\t\tf = n => _isAttribute(n) && regex.test(n.name);\n\t\t\t// no direct access\n\t\t\tqname = null;\n\t\t} else {\n\t\t\t// name check provided by directAccess\n\t\t\tf = n => _isAttribute(n);\n\t\t}\n\t\treturn Axis(_attrGet.bind(null,qname),filter(f),2);\n\t});\n}\n\nexport function text() {\n\tvar f = n => _isText(n) && !!n.value;\n\tf.__is_NodeTypeTest = true;\n\treturn f;\n}\n\nexport function node() {\n\tvar f = n => _isElement(n) || (_isText(n) && !!n.value);\n\tf.__is_NodeTypeTest = true;\n\treturn seq(f);\n}\n\n// TODO create axis functions that return a function\n// child(element(qname))\n// works like a filter: filter(children(node|nodelist),n => element(qname,n))\n// nextSibling(element()): filter(nextSibling(node|nodelist),n => element(undefined,n))\n// filterOrGet: when f is called, and null or wildcard match was supplied as its qname parameter, call filter\n// else call get\n// if it is a seq, apply the function iteratively:\n// we don't want to filter all elements from a seq, we want to retrieve all elements from elements in a seq\n// final edge case: when node is of type array, and name is not an integer: filter\nfunction Axis(g,f,type){\n\treturn {\n\t\t__is_Axis: true,\n\t\t__type: type || 1,\n\t\tf:f,\n\t\tg:g\n\t};\n}\nexport function child(f) {\n\tconst cx = this;\n\tif(f.__is_NodeTypeTest){\n\t\t// this means it's a predicate, and the actual function should become a filter\n\t\tif(f.__Accessor) {\n\t\t\t// TODO this means we can try direct access on a node\n\t\t}\n\t\tf = filter(f);\n\t}\n\treturn Axis(node => children.bind(cx)(node),f);\n}\n\nexport function siblingsOrSelf($node){\n\tvar cx = this;\n\treturn switchMap(ensureDoc.bind(cx)($node),node => children.bind(cx)(node.parent));\n}\n\nexport function select($node, ...paths) {\n\tvar cx = this;\n\tvar boundEnsureDoc = ensureDoc.bind(cx);\n\treturn foldLeft(forEach(\n\t\tforEach(from(paths),path => _axify(path)),\n\t\t// we're passing $node here, because we want to update it every iteration\n\t\tpath => $node => {\n\t\t\t// make sure all paths are funcs\n\t\t\t// TODO skip self\n\t\t\tvar skipCompare = path.__type == 2 || path.__type == 3;\n\t\t\tvar f = path.f;\n\t\t\t// rebind step function to the context\n\t\t\tvar bound = function bound(n) {\n\t\t\t\treturn path.g(boundEnsureDoc(n));\n\t\t\t};\n\t\t\tif (!skipCompare) f = pipe(f, filter(_comparer()));\n\t\t\treturn switchMap($node,node => f(bound(node)));\n\t\t}),boundEnsureDoc($node),($node, changeFn) => changeFn($node));\n}\n\nfunction _comparer() {\n\t// dirty preserve state on function\n\tvar f = function (node) {\n\t\tvar has = f._checked.has(node);\n\t\tif (!has) f._checked.set(node,true);\n\t\treturn !has;\n\t};\n\tf._checked = new WeakMap();\n\treturn f;\n}\n\nfunction _axify($path){\n\treturn switchMap($path,path => {\n\t\tif(!path.__is_Axis){\n\t\t\t// process strings (can this be combined?)\n\t\t\tif (typeof path == \"string\") {\n\t\t\t\tvar at = /^@/.test(path);\n\t\t\t\tif (at) path = path.substring(1);\n\t\t\t\treturn at ? attribute(path) : child(element(path));\n\t\t\t} else if(typeof path == \"function\"){\n\t\t\t\tif(path.__is_NodeTypeTest) return child(path);\n\t\t\t\treturn self(path);\n\t\t\t} else {\n\t\t\t\treturn error(\"XXX\",\"Unknown axis provided\");\n\t\t\t}\n\t\t}\n\t\treturn seq(path);\n\t});\n}\n\nexport function isEmptyNode(node){\n\tnode = ensureDoc.bind(this)(node);\n\tif(!isVNode(node)) return false;\n\tif(_isText(node) || _isLiteral(node) || _isAttribute(node)) return node.value === undefined;\n\treturn !node.count();\n}\n\nexport function name($a) {\n\tif(!arguments.length) return name;\n\treturn switchMap($a,a => {\n\t\tif (!isVNode(a)) {\n\t\t\treturn error(\"XXX\",\"This is not a node\");\n\t\t}\n\t\tif(a.type != 1) return null;\n\t\treturn a.name;\n\t});\n}\n"],"file":"access.js"}