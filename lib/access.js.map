{"version":3,"sources":["../src/access.js"],"names":["_vnodeFromCx","cx","node","vnode","children","$node","ensureDoc","bind","concatMap","values","type","inode","depth","map","idx","firstChild","next","first","_nextOrPrev","dir","parent","sib","indexInParent","nextSibling","previousSibling","getDoc","lastChild","last","count","arguments","length","Axis","self","$f","f","name","isVNode","n","__is_VNode","_isElement","_isAttribute","_isText","_isList","_isMap","_isPI","_isComment","_isLiteral","cxFilter","iterable","v","k","i","__cx","position","size","_isEq","a","b","_nodeTest","typeTest","qnameOrKey","undefined","hasWildcard","test","regex","RegExp","replace","isTuple","key","__Accessor","__is_NodeTypeTest","element","qname","list","keyOrIndex","processingInstruction","comment","_attrGet","entries","val","attr","attrEntries","kv","pair","attribute","$qname","text","value","g","__is_Axis","__type","child","siblingsOrSelf","select","paths","boundEnsureDoc","path","_axify","skipCompare","bound","_comparer","reduce","changeFn","concatAll","has","_checked","set","WeakMap","$path","at","substring","isEmptyNode","$a"],"mappings":"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","sourcesContent":["import { ensureDoc } from \"l3n\";\r\n\r\nimport { error } from \"./error\";\r\n\r\nimport { seq, isSeq, forEach, filter, pipe } from \"./seq\";\r\n\r\nimport { zeroOrOne, exactlyOne } from \"./seq/card\";\r\n\r\nimport { isUndef } from \"./util\";\r\n\r\nconst _vnodeFromCx = (cx,node) => cx && \"vnode\" in cx ? cx.vnode : node.cx.vnode;\r\n\r\nexport function children($node) {\r\n\tconst cx = this;\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => {\r\n\t\tconst vnode = _vnodeFromCx(cx,node);\r\n\t\tconst values = node.type == 2 ? [node.inode] : node.values();\r\n\t\tconst depth = node.depth + 1;\r\n\t\treturn seq(values).map((inode, idx) => vnode(inode,node,depth,idx + 1));\r\n\t});\r\n}\r\n\r\nexport function firstChild($node) {\r\n\tconst cx = this;\r\n\t// assume ensureDoc returns the correct node\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => {\r\n\t\tconst vnode = _vnodeFromCx(cx,node);\r\n\t\tlet next = node.first();\r\n\t\treturn next ? seq(vnode(next,node,node.depth + 1, 0)) : seq();\r\n\t});\r\n}\r\n\r\nconst _nextOrPrev = (cx,$node,dir) => {\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => {\r\n\t\tconst vnode = _vnodeFromCx(cx,node);\r\n\t\tvar parent = node.parent;\r\n\t\tconst sib = parent && parent[dir > 0 ? \"next\" : \"previous\"](node);\r\n\t\treturn sib ? seq(vnode(sib, parent, node.depth, node.indexInParent + dir)) : seq();\r\n\t});\r\n};\r\n\r\nexport function nextSibling($node){\r\n\treturn _nextOrPrev(this, $node, 1);\r\n}\r\n\r\nexport function previousSibling($node){\r\n\treturn _nextOrPrev(this, $node, -1);\r\n}\r\n\r\nexport function getDoc($node) {\r\n\tvar cx = this;\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => {\r\n\t\tdo {\r\n\t\t\tnode = node.parent;\r\n\t\t} while(node.parent);\r\n\t\treturn seq(node);\r\n\t});\r\n}\r\n\r\nexport function lastChild($node){\r\n\tvar cx = this;\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => {\r\n\t\tconst last = node.last();\r\n\t\tconst vnode = cx.vnode || node.cx.vnode;\r\n\t\treturn last ? seq(vnode(last, node, node.depth, node.count() - 1)) : seq();\r\n\t});\r\n}\r\n\r\nexport function parent($node) {\r\n\tif(!arguments.length) return Axis(parent);\r\n\tvar cx = this;\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => seq(node.parent));\r\n}\r\n\r\nexport function self($f) {\r\n\treturn zeroOrOne($f).map(f => {\r\n\t\tif(f.name !== \"forEach\" && f.name !== \"filter\") f = forEach(f);\r\n\t\treturn Axis(node => node, f, 3);\r\n\t});\r\n}\r\n\r\nexport const isVNode = n => !!n && n.__is_VNode;\r\n\r\nconst _isElement = n => isVNode(n) && n.type == 1;\r\n\r\nconst _isAttribute = n => isVNode(n) && n.type == 2;\r\n\r\nconst _isText = n => isVNode(n) && n.type == 3;\r\n\r\nconst _isList = n => isVNode(n) && n.type == 5;\r\n\r\nconst _isMap = n => isVNode(n) && n.type == 6;\r\n\r\nconst _isPI = n => isVNode(n) && n.type == 7;\r\n\r\nconst _isComment = n => isVNode(n) && n.type == 8;\r\n\r\nconst _isLiteral = n => isVNode(n) && n.type == 12;\r\n\r\nexport function cxFilter(iterable,f){\r\n\treturn filter(iterable,function(v,k,i){\r\n\t\tif(!isSeq(v) && !isVNode(v)) v = seq(v);\r\n\t\tv.__cx = [k,i];\r\n\t\treturn f(v,k,i);\r\n\t});\r\n}\r\n\r\nexport const position = n => n.__cx ? n.__cx[0] + 1 : n.indexInParent;\r\n\r\nexport const last = n => n.__cx ? n.__cx[1].size : n.parent ? n.parent.size : 1;\r\n\r\nconst _isEq = (a,b) => a === b;\r\n\r\n// TODO convert qname to integer when parent is array\r\nfunction _nodeTest(typeTest,qnameOrKey) {\r\n\tvar f;\r\n\tif (qnameOrKey === undefined) {\r\n\t\tf = typeTest;\r\n\t} else {\r\n\t\tvar hasWildcard = /\\*/.test(qnameOrKey);\r\n\t\tif (hasWildcard) {\r\n\t\t\tvar regex = new RegExp(qnameOrKey.replace(/\\*/, \"(\\\\w[\\\\w0-9-_]*)\"));\r\n\t\t\tf = n => {\r\n\t\t\t\tlet isTuple = n.parent.type == 6;\r\n\t\t\t\tif(isTuple || n.name) {\r\n\t\t\t\t\treturn typeTest(n) && regex.test(isTuple ? n.key : n.name);\r\n\t\t\t\t}\r\n\t\t\t\treturn typeTest(n);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tf = n => {\r\n\t\t\t\tlet isTuple = n.parent.type == 6;\r\n\t\t\t\tif(isTuple || n.name) {\r\n\t\t\t\t\treturn _isEq(isTuple ? n.key : n.name,qnameOrKey) && typeTest(n);\r\n\t\t\t\t}\r\n\t\t\t\treturn typeTest(n);\r\n\t\t\t};\r\n\t\t\tf.__Accessor = qnameOrKey;\r\n\t\t}\r\n\t}\r\n\tf.__is_NodeTypeTest = true;\r\n\treturn f;\r\n}\r\n\r\nexport function element(qname) {\r\n\treturn _nodeTest(_isElement,qname);\r\n}\r\n\r\nexport function list(keyOrIndex) {\r\n\treturn _nodeTest(_isList,keyOrIndex);\r\n}\r\n\r\nexport function map() {\r\n\treturn _nodeTest(_isMap);\r\n}\r\n\r\nexport function processingInstruction() {\r\n\treturn _nodeTest(_isPI);\r\n}\r\n\r\nexport function comment() {\r\n\treturn _nodeTest(_isComment);\r\n}\r\n\r\nfunction _attrGet(key,$node){\r\n\treturn seq($node).concatMap(node => {\r\n\t\tvar entries;\r\n\t\tif (key !== null) {\r\n\t\t\tvar val = node.attr(key);\r\n\t\t\tif (!val) return [];\r\n\t\t\tentries = [[key, val]];\r\n\t\t} else {\r\n\t\t\tentries = node.attrEntries();\r\n\t\t}\r\n\t\treturn seq(entries).map(function (kv) {\r\n\t\t\treturn node.vnode(node.pair(kv[0], kv[1]), node.parent, node.depth + 1, node.indexInParent);\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// TODO make axis default, process node here, return seq(VNodeIterator)\r\n// TODO maybe have Axis receive post-process func/seq\r\nexport function attribute($qname) {\r\n\tif(isUndef($qname)) $qname = \"*\";\r\n\treturn exactlyOne($qname).map(qname => {\r\n\t\tvar hasWildcard = /\\*/.test(qname);\r\n\t\t// getter of attributes / pre-processor of attributes\r\n\t\t// TODO iterator!\r\n\t\t// filter of attributes\r\n\t\tvar f;\r\n\t\tif (hasWildcard) {\r\n\t\t\tvar regex = new RegExp(qname.replace(/\\*/, \"(\\\\w[\\\\w0-9-_]*)\"));\r\n\t\t\t//\tattrEntries returns tuples\r\n\t\t\tf = n => _isAttribute(n) && regex.test(n.name);\r\n\t\t\t// no direct access\r\n\t\t\tqname = null;\r\n\t\t} else {\r\n\t\t\t// name check provided by directAccess\r\n\t\t\tf = n => _isAttribute(n);\r\n\t\t}\r\n\t\treturn Axis(_attrGet.bind(null,qname),filter(f),2);\r\n\t});\r\n}\r\n\r\nexport function text() {\r\n\tvar f = n => _isText(n) && !!n.value;\r\n\tf.__is_NodeTypeTest = true;\r\n\treturn seq(f);\r\n}\r\n\r\nexport function node() {\r\n\tvar f = n => _isElement(n) || (_isText(n) && !!n.value);\r\n\tf.__is_NodeTypeTest = true;\r\n\treturn seq(f);\r\n}\r\n\r\n// TODO create axis functions that return a function\r\n// child(element(qname))\r\n// works like a filter: filter(children(node|nodelist),n => element(qname,n))\r\n// nextSibling(element()): filter(nextSibling(node|nodelist),n => element(undefined,n))\r\n// filterOrGet: when f is called, and null or wildcard match was supplied as its qname parameter, call filter\r\n// else call get\r\n// if it is a seq, apply the function iteratively:\r\n// we don't want to filter all elements from a seq, we want to retrieve all elements from elements in a seq\r\n// final edge case: when node is of type array, and name is not an integer: filter\r\nfunction Axis(g,f,type){\r\n\treturn {\r\n\t\t__is_Axis: true,\r\n\t\t__type: type || 1,\r\n\t\tf:f,\r\n\t\tg:g\r\n\t};\r\n}\r\nexport function child($f) {\r\n\tconst cx = this;\r\n\treturn forEach(zeroOrOne($f),f => {\r\n\t\tif(f.__is_NodeTypeTest){\r\n\t\t\t// this means it's a predicate, and the actual function should become a filter\r\n\t\t\tif(f.__Accessor) {\r\n\t\t\t\t// TODO this means we can try direct access on a node\r\n\t\t\t}\r\n\t\t\tf = filter(f);\r\n\t\t}\r\n\t\treturn Axis(node => children.bind(cx)(node),f);\r\n\t});\r\n}\r\n\r\nexport function siblingsOrSelf($node){\r\n\tvar cx = this;\r\n\treturn ensureDoc.bind(cx)($node).concatMap(node => children.bind(cx)(node.parent));\r\n}\r\n\r\nexport function select($node, ...paths) {\r\n\tvar cx = this;\r\n\tvar boundEnsureDoc = ensureDoc.bind(cx);\r\n\treturn seq(forEach(paths,\r\n\t\tpath => _axify(path)))\r\n\t\t// we're passing $node here, because we want to update it every iteration\r\n\t\t.map(path => $node => {\r\n\t\t\t// make sure all paths are funcs\r\n\t\t\t// TODO skip self\r\n\t\t\tvar skipCompare = path.__type == 2 || path.__type == 3;\r\n\t\t\tvar f = path.f;\r\n\t\t\t// rebind step function to the context\r\n\t\t\tvar bound = function bound(n) {\r\n\t\t\t\treturn path.g(boundEnsureDoc(n));\r\n\t\t\t};\r\n\t\t\tif (!skipCompare) f = pipe(f, filter(_comparer()));\r\n\t\t\treturn seq($node).concatMap(node => f(bound(node)));\r\n\t\t})\r\n\t\t.reduce(($node, changeFn) => changeFn($node),boundEnsureDoc($node))\r\n\t\t.concatAll();\r\n}\r\n\r\nfunction _comparer() {\r\n\t// dirty preserve state on function\r\n\tvar f = function (node) {\r\n\t\tvar has = f._checked.has(node);\r\n\t\tif (!has) f._checked.set(node,true);\r\n\t\treturn !has;\r\n\t};\r\n\tf._checked = new WeakMap();\r\n\treturn f;\r\n}\r\n\r\n/*\r\nexport function* select2(node,...paths) {\r\n\t// TODO\r\n\t// 1: node (or seq) is iterable, so get first as current context\r\n\t// 2: each function is a filter (either a node is returned or the process stops)\r\n\t// 3: pass each single result to a filter function, yielding a result for each\r\n\tvar bed = ensureDoc.bind(this);\r\n\tvar next = bed(node);\r\n\tvar cx = next;\r\n\tif(next) {\r\n\t\tnext = nextNode(next);\r\n\t\twhile(next){\r\n\t\t\tfor(var i=0,l=paths.length,path=paths[i]; i<l; i++){\r\n\t\t\t\tif(!isSeq(path)) path = seq(path);\r\n\t\t\t\t// process strings (can this be combined?)\r\n\t\t\t\tpath = transform(path,compose(forEach(function(path){\r\n\t\t\t\t\tif(typeof path == \"string\") {\r\n\t\t\t\t\t\tvar at = /^@/.test(path);\r\n\t\t\t\t\t\tif(at) path = path.substring(1);\r\n\t\t\t\t\t\treturn at ? attribute(path) : element(path);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn [path];\r\n\t\t\t\t}),cat));\r\n\t\t\t\tvar composed = compose.apply(null,path.toArray());\r\n\t\t\t\tlet ret = composed.call(cx,next);\r\n\t\t\t\tif(node) {\r\n\t\t\t\t\tyield ret;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n*/\r\nfunction _axify($path){\r\n\treturn seq($path).concatMap(path => {\r\n\t\tif(!path.__is_Axis){\r\n\t\t\t// process strings (can this be combined?)\r\n\t\t\tif (typeof path == \"string\") {\r\n\t\t\t\tvar at = /^@/.test(path);\r\n\t\t\t\tif (at) path = path.substring(1);\r\n\t\t\t\treturn at ? attribute(path) : child(element(path));\r\n\t\t\t} else if(typeof path == \"function\"){\r\n\t\t\t\tif(path.__is_NodeTypeTest) return child(path);\r\n\t\t\t\treturn self(path);\r\n\t\t\t} else {\r\n\t\t\t\treturn error(\"XXX\",\"Unknown axis provided\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn seq(path);\r\n\t});\r\n}\r\n\r\nexport function isEmptyNode(node){\r\n\tnode = ensureDoc.bind(this)(node);\r\n\tif(!isVNode(node)) return false;\r\n\tif(_isText(node) || _isLiteral(node) || _isAttribute(node)) return node.value === undefined;\r\n\treturn !node.count();\r\n}\r\n\r\nexport function name($a) {\r\n\tif(!arguments.length) return name;\r\n\treturn seq($a).concatMap(a => {\r\n\t\tif (!isVNode(a)) {\r\n\t\t\treturn error(\"XXX\",\"This is not a node\");\r\n\t\t}\r\n\t\tif(a.type != 1) return seq();\r\n\t\treturn seq(a.name);\r\n\t});\r\n}\r\n"],"file":"access.js"}