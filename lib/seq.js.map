{"version":3,"sources":["../src/seq.js"],"names":["Maybe","Observable","toObservable","create","$o","subscribe","Single","isMaybe","x","isSingle","prototype","toSingle","toMaybe","fromArgs","args","seq","map","pipe","isSeq","isObservable","wrap","fn","ret","Scheduler","queue","forEachCurried","$s","forEach","filterCurried","t","filter","foldLeftCurried","$seed","$a","a","switchMapCurried","id","foldLeft","scanCurried","scan","fromType","len","length","just","o","first","f","d","s","range","n","unsubscribeOn","scheduler","source","observer","subscription","schedule","unsubscribe","switchMap","sort","toArray"],"mappings":"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","sourcesContent":["import { Observable, Scheduler, isObservable, of, from, range as rxRange, empty as rxEmpty, pipe, interval } from \"rxjs\";\nimport {\n\tfirst as rxFirst,\n\tsubscribeOn,\n\tmap,\n\tmergeMap,\n\tconcatMap,\n\tswitchMap as rxSwitchMap,\n\tconcatAll,\n\treduce,\n\tfilter as rxFilter,\n\tscan as rxScan,\n\tpairwise\n} from \"rxjs/operators\";\n\nimport { isPromise, isUndef, isUndefOrNull, isNull, id } from \"./util\";\nimport { boolean } from \"./boolean/value\";\n\n\nexport class Maybe extends Observable {\n\ttoObservable() {\n\t\treturn create($o => {\n\t\t\tthis.subscribe($o);\n\t\t});\n\t}\n}\n\nexport class Single extends Observable {\n\ttoObservable() {\n\t\treturn create($o => {\n\t\t\tthis.subscribe($o);\n\t\t});\n\t}\n}\n\nexport const isMaybe = x => !!(x && x instanceof Maybe);\n\nexport const isSingle = x => !!(x && x instanceof Single);\n\nObservable.prototype.toSingle = function() {\n\treturn new Single($o => {\n\t\trxFirst()(this).subscribe($o);\n\t});\n};\n\nObservable.prototype.toMaybe = function() {\n\treturn new Maybe($o => {\n\t\trxFirst()(this).subscribe($o);\n\t});\n};\n\n// TODO check each arg for Observable\nexport const fromArgs = args => seq(args.map(x => seq(x))).pipe(concatAll());\n\nexport const isSeq = isObservable;\n\nconst wrap = fn => x => {\n\tconst ret = fn(x);\n\treturn isSeq(ret) || isPromise(ret) ? ret : subscribeOn(Scheduler.queue)(of(ret).toSingle());\n};\n\nexport const forEachCurried = fn => $s => isSeq($s) ? mergeMap(wrap(fn))($s) : fn($s);\n\nexport function forEach($s, fn) {\n\treturn !isUndef(fn) ? forEachCurried(fn)($s) : forEachCurried($s);\n}\n\n/**\n * curried filter\n * @param  {function} fn [description]\n * @return {function}     [description]\n */\nexport const filterCurried = fn => $s =>\n\tisSeq($s) ?\n\t\tpipe(mergeMap(x => pairwise()(seq(boolean(fn(x)),x))),rxFilter(([t]) => t),map(([,x]) => x))($s) :\n\t\tpipe(rxFilter(t => t),map(() => $s))(seq(fn($s)));\n\nexport function filter($s, fn) {\n\treturn !isUndef(fn) ? filterCurried(fn)($s) : filterCurried($s);\n}\n\nexport const foldLeftCurried = fn => $seed => $a =>\n\tisSeq($a) ?\n\t\tpipe(reduce((a,x) => fn(a,x),$seed),switchMapCurried(id))($a) :\n\t\tfn($seed,$a);\n\nexport function foldLeft($a, $seed, fn) {\n\treturn !isUndef(fn) ? foldLeftCurried(fn)($seed)($a) : foldLeftCurried($seed)($a);\n}\n\nexport const scanCurried = fn => $seed => $a =>\n\tisSeq($a) ?\n\t\tpipe(rxScan((a,x) => fn(a,x),$seed),forEachCurried(x => x))($a) :\n\t\tfn($seed,$a);\n\nexport function scan($a,$seed,fn) {\n\treturn !isUndef(fn) ? scanCurried(fn)($seed)($a) : scanCurried($seed)($a);\n}\n\nfunction fromType(x) {\n\treturn isSeq(x) ? x : isUndefOrNull(x) ? rxEmpty() : of(x).toSingle();\n}\n\nexport function seq(...a) {\n\tconst len = a.length;\n\tif (len == 0) return fromType();\n\tif(len == 1) return fromType(a[0]);\n\treturn concatMap(x => seq(x))(from(a));\n}\n\nexport function just(a) {\n\treturn (isSeq(a) ? a : of(a)).toSingle();\n}\n\nexport function create(o){\n\treturn Observable.create(o);\n}\n\n// TODO how to use f when not a seq?\nexport const first = (f,d) => s => isSeq(s) ? rxFirst(f,d)(s) : isNull(s) ? d : s;\n\nexport function range(n,s=0) {\n\treturn subscribeOn(Scheduler.queue)(rxRange(s,n));\n}\n\nexport const switchMapCurried = fn => $s => isSeq($s) ? pipe(\n\trxSwitchMap(wrap(fn)),\n\tsubscribeOn(Scheduler.queue),\n\tunsubscribeOn(Scheduler.queue))($s) : fn($s);\n\nfunction unsubscribeOn(scheduler) {\n\treturn source => create(observer => {\n\t\tconst subscription = source.subscribe(observer);\n\t\treturn () => scheduler.schedule(() => subscription.unsubscribe());\n\t});\n}\n\nexport const switchMap = ($s,fn) => !isUndef(fn) ? switchMapCurried(fn)($s) : switchMapCurried($s);\n\n// FIXME\nexport function sort($s,fn){\n\treturn switchMap(seq($s).toArray(),a => seq(isUndef(fn) ? a.sort() : a.sort(fn)));\n}\n\nexport { pipe, interval, from };\n"],"file":"seq.js"}