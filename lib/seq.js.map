{"version":3,"sources":["../src/seq.js"],"names":["Maybe","Observable","toObservable","create","$o","subscribe","Single","isMaybe","x","isSingle","prototype","toSingle","toMaybe","fromArgs","args","seq","map","pipe","isSeq","isObservable","wrap","fn","ret","Scheduler","queue","forEachCurried","$s","forEach","filterCurried","t","filter","foldLeftCurried","$seed","$a","a","switchMap","id","foldLeft","scanCurried","scan","fromType","len","length","just","o","first","f","d","s","count","range","n","switchMapCurried","unsubscribeOn","scheduler","source","observer","subscription","schedule","unsubscribe"],"mappings":"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","sourcesContent":["import { Observable, Scheduler, isObservable, of, from, range as rxRange, empty as rxEmpty, pipe } from \"rxjs\";\r\nimport {\r\n\tfirst as rxFirst,\r\n\tsubscribeOn,\r\n\tmap,\r\n\tmergeMap,\r\n\tconcatMap,\r\n\tswitchMap as rxSwitchMap,\r\n\tconcatAll,\r\n\treduce,\r\n\tfilter as rxFilter,\r\n\tcount as rxCount,\r\n\tpairwise\r\n} from \"rxjs/operators\";\r\n\r\nimport { isPromise, isUndef, isUndefOrNull, isNull, id } from \"./util\";\r\nimport { boolean } from \"./boolean/value\";\r\n\r\n\r\nexport class Maybe extends Observable {\r\n\ttoObservable() {\r\n\t\treturn create($o => {\r\n\t\t\tthis.subscribe($o);\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport class Single extends Observable {\r\n\ttoObservable() {\r\n\t\treturn create($o => {\r\n\t\t\tthis.subscribe($o);\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport const isMaybe = x => !!(x && x instanceof Maybe);\r\n\r\nexport const isSingle = x => !!(x && x instanceof Single);\r\n\r\nObservable.prototype.toSingle = function() {\r\n\treturn new Single($o => {\r\n\t\trxFirst()(this).subscribe($o);\r\n\t});\r\n};\r\n\r\nObservable.prototype.toMaybe = function() {\r\n\treturn new Maybe($o => {\r\n\t\trxFirst()(this).subscribe($o);\r\n\t});\r\n};\r\n\r\n// TODO check each arg for Observable\r\nexport const fromArgs = args => seq(args.map(x => seq(x))).pipe(concatAll());\r\n\r\nexport const isSeq = isObservable;\r\n\r\nconst wrap = fn => x => {\r\n\tconst ret = fn(x);\r\n\treturn isSeq(ret) || isPromise(ret) ? ret : subscribeOn(Scheduler.queue)(of(ret).toSingle());\r\n};\r\n\r\nexport const forEachCurried = fn => $s => isSeq($s) ? mergeMap(wrap(fn))($s) : fn($s);\r\n\r\nexport function forEach($s, fn) {\r\n\treturn !isUndef(fn) ? forEachCurried(fn)($s) : forEachCurried($s);\r\n}\r\n\r\n/**\r\n * curried filter\r\n * @param  {function} fn [description]\r\n * @return {function}     [description]\r\n */\r\nexport const filterCurried = fn => $s =>\r\n\tisSeq($s) ?\r\n\t\tpipe(mergeMap(x => pairwise()(seq(boolean(fn(x)),x))),rxFilter(([t]) => t),map(([,x]) => x))($s) :\r\n\t\tpipe(rxFilter(t => t),map(() => $s))(seq(fn($s)));\r\n\r\nexport function filter($s, fn) {\r\n\treturn !isUndef(fn) ? filterCurried(fn)($s) : filterCurried($s);\r\n}\r\n\r\nexport const foldLeftCurried = fn => $seed => $a =>\r\n\tisSeq($a) ?\r\n\t\tpipe(reduce((a,x) => fn(a,x),$seed),switchMap(id))($a) :\r\n\t\tfn($seed,$a);\r\n\r\nexport function foldLeft($a, $seed, fn) {\r\n\treturn !isUndef(fn) ? foldLeftCurried(fn)($seed)($a) : foldLeftCurried($seed)($a);\r\n}\r\n\r\nexport const scanCurried = fn => $seed => $a =>\r\n\tisSeq($a) ?\r\n\t\tpipe(scan((a,x) => fn(a,x),$seed),switchMap(x => x))($a) :\r\n\t\tfn($seed,$a);\r\n\r\nexport function scan($a,$seed,fn) {\r\n\treturn !isUndef(fn) ? scanCurried(fn)($seed)($a) : scanCurried($seed)($a);\r\n}\r\n\r\nfunction fromType(x) {\r\n\treturn isSeq(x) ? x : isUndefOrNull(x) ? rxEmpty() : of(x).toSingle();\r\n}\r\n\r\nexport function seq(...a) {\r\n\tconst len = a.length;\r\n\tif (len == 0) return fromType();\r\n\tif(len == 1) return fromType(a[0]);\r\n\treturn concatMap(x => seq(x))(from(a));\r\n}\r\n\r\nexport function just(a) {\r\n\treturn (isSeq(a) ? a : of(a)).toSingle();\r\n}\r\n\r\nexport function create(o){\r\n\treturn Observable.create(o);\r\n}\r\n\r\n// TODO how to use f when not a seq?\r\nexport const first = (f,d) => s => isSeq(s) ? rxFirst(f,d)(s) : isNull(s) ? d : s;\r\n\r\nexport const count = s => isSeq(s) ? rxCount()(s) : 1;\r\n\r\nexport function range(n,s=0) {\r\n\treturn subscribeOn(Scheduler.queue)(rxRange(s,n));\r\n}\r\n\r\nexport const switchMapCurried = fn => $s => isSeq($s) ? pipe(\r\n\trxSwitchMap(wrap(fn)),\r\n\tsubscribeOn(Scheduler.queue),\r\n\tunsubscribeOn(Scheduler.queue))($s) : fn($s);\r\n\r\nfunction unsubscribeOn(scheduler) {\r\n\treturn source => create(observer => {\r\n\t\tconst subscription = source.subscribe(observer);\r\n\t\treturn () => scheduler.schedule(() => subscription.unsubscribe());\r\n\t});\r\n}\r\n\r\nexport const switchMap = ($s,fn) => !isUndef(fn) ? switchMapCurried(fn)($s) : switchMapCurried($s);\r\n\r\nexport { pipe };\r\n"],"file":"seq.js"}