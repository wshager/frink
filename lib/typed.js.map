{"version":3,"sources":["../src/typed.js"],"names":["check","checked","f","a","t","hasOwnProperty","__wraps","Error","TypeError","constructor","name","errorMessage","i","pos","key","noKey","io","typePart","JSON","stringify","occurrence","test","occ","err","__occurrence","any","id","many","oneOrMore","maybe","zeroOrOne","single","exactlyOne","unwrap","fn","args","s","r","l","o","ret","subscribe","unwrapMaybe","value","next","error","complete","bind","unwrapSingle","c","getStack","orig","prepareStackTrace","_","stack","captureStackTrace","checkArgLength","al","sl","length","__optional","def","st","getFunctionName","getFileName","getLineNumber","getColumnNumber","array","x","map","item","opt","arg","atomic","b","isNumeric","numeric"],"mappings":"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","sourcesContent":["import { seq, isSeq, create, forEach } from \"./seq\";\r\n\r\nimport { exactlyOne, zeroOrOne, oneOrMore } from \"./seq/card\";\r\n\r\nimport { id, isUndef, isList, isMap } from \"./util\";\r\n\r\nimport { array as makeArray } from \"./array\";\r\n\r\nimport { map as makeMap } from \"./map\";\r\n\r\n// TODO make configurable\r\nconst check = true;\r\n\r\n// we know typed will take a function and test it,\r\n// so we can use the same function here to bind the subscriber\r\n// we should run two tests:\r\n// 1. the cardinality\r\n// 2. the actual type\r\n// furthermore, we should\r\n// 3. unwrap Maybe (allowing nulls or preventing type tests) and Single\r\n// 4. connect types for Flowable to subscriber\r\n\r\n// wrap card + type, if isSeq, don't perform type test, but bind to subscriber:\r\n\r\nconst checked = (f,a) => {\r\n\tconst t = f(a);\r\n\tif(typeof t == \"function\" && t.hasOwnProperty(\"__wraps\")) {\r\n\t\tif(t.__wraps !== a) throw new Error(\"unknown function found\");\r\n\t} else {\r\n\t\tif(a !== t) throw new TypeError(\"Incorrect type: expected \"+t.constructor.name+\", got \"+a.constructor.name);\r\n\t}\r\n\treturn t;\r\n};\r\n\r\n\r\nconst errorMessage = (a,name,i,pos,key) => {\r\n\tif(isUndef(a) || isUndef(name)) return \"Invalid value\\n\";\r\n\tconst noKey = isUndef(key);\r\n\tif(noKey) key = \"argument\";\r\n\tconst io = i < 0 ? \"output\" : key+\" \"+(typeof i == \"string\" ? `\"${i}\"` :  i);\r\n\tconst typePart = noKey ? `for function '${name}'\\n    at ${pos[0]} (${pos[1]}:${pos[2]}:${pos[3]})` : `found in ${name}`;\r\n\treturn \"Invalid \"+io+\" *\"+JSON.stringify(a)+\"* \"+typePart + \"\\n\";\r\n};\r\n\r\nexport const occurrence = (test,occ) => f => {\r\n\tconst t = (a,name,i,pos,key) => forEach(a,a => {\r\n\t\ttry {\r\n\t\t\treturn checked(f, test(a));\r\n\t\t} catch(err) {\r\n\t\t\tthrow new Error(errorMessage(a,name,i,pos,key)+err);\r\n\t\t}\r\n\t});\r\n\tt.__occurrence = occ;\r\n\treturn t;\r\n};\r\nexport const any = occurrence(id,1);\r\nexport const many = occurrence(oneOrMore,2);\r\nexport const maybe = occurrence(zeroOrOne,3);\r\nexport const single = occurrence(exactlyOne,4);\r\n\r\nfunction unwrap(fn,args,s,r,name,pos,l,i,o) {\r\n\tif(i === l) {\r\n\t\tconst ret = fn();\r\n\t\treturn o ? seq(ret).subscribe(o) : ret;\r\n\t}\r\n\tconst unwrapMaybe = o => a => {\r\n\t\tlet value = null;\r\n\t\ta.subscribe({\r\n\t\t\tnext(a) {\r\n\t\t\t\tvalue = a;\r\n\t\t\t},\r\n\t\t\terror(err) {\r\n\t\t\t\to.error(err);\r\n\t\t\t},\r\n\t\t\tcomplete() {\r\n\t\t\t\tunwrap(fn.bind(null,value),args,s,r,name,pos,l,i+1,o);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\tconst unwrapSingle = o => a => a.subscribe({\r\n\t\tnext(a) {\r\n\t\t\tunwrap(fn.bind(null,a),args,s,r,name,pos,l,i+1,o);\r\n\t\t},\r\n\t\terror(err) {\r\n\t\t\to.error(err);\r\n\t\t}\r\n\t});\r\n\tlet f = s[i];\r\n\tconst c = f.__occurrence;\r\n\tif(isUndef(c)) f = single(f);\r\n\tconst a = check ? f(args[i],name,i,pos) : args[i];\r\n\tif(isSeq(a)) {\r\n\t\t// when we unwrap we get back an Observable, not a function...\r\n\t\tif(c === 3) {\r\n\t\t\tif(!o) {\r\n\t\t\t\treturn create(o => {\r\n\t\t\t\t\tunwrapMaybe(o)(a);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn unwrapMaybe(o)(a);\r\n\t\t\t}\r\n\t\t} else if(c === 4) {\r\n\t\t\tif(!o) {\r\n\t\t\t\treturn create(o => {\r\n\t\t\t\t\tunwrapSingle(o)(a);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn unwrapSingle(o)(a);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn unwrap(fn.bind(null,a),args,s,r,name,pos,l,i+1,o);\r\n}\r\n\r\n// TODO use separate cross-browser package conditionally\r\nfunction getStack(){\r\n\tvar orig = Error.prepareStackTrace;\r\n\tError.prepareStackTrace = function(_, stack) {\r\n\t\treturn stack;\r\n\t};\r\n\tvar err = new Error;\r\n\tError.captureStackTrace(err);\r\n\tvar stack = err.stack;\r\n\tError.prepareStackTrace = orig;\r\n\treturn stack;\r\n}\r\n\r\nfunction checkArgLength(name,s,al) {\r\n\tlet sl = s.length;\r\n\twhile(sl > al) {\r\n\t\tif(!s[--sl].__optional) break;\r\n\t}\r\n\tif(al !== sl) {\r\n\t\tthrow new Error(`Invalid number of arguments for function ${name}. Expected ${sl} got ${al}`);\r\n\t}\r\n}\r\n\r\nexport const def = (name,s,r,pos) => fn => {\r\n\tif(typeof fn !== \"function\") throw new TypeError(\"Invalid argument for function 'def'\\nExpected a Function, got a \"+fn.constructor.name);\r\n\tif(isUndef(pos)) {\r\n\t\tvar st = getStack()[2];\r\n\t\tpos = [st.getFunctionName(),st.getFileName(),st.getLineNumber(),st.getColumnNumber()];\r\n\t}\r\n\tconst f = (...args) => {\r\n\t\tconst al = args.length;\r\n\t\tcheckArgLength(name,s,al);\r\n\t\tconst ret = unwrap(fn,args,s,r,name,pos,al,0);\r\n\t\treturn check ? r(ret,name,-1,pos) : ret;\r\n\t};\r\n\tf.__wraps = fn;\r\n\treturn f;\r\n};\r\n\r\nexport const array = f => a => {\r\n\tif(!isList(a)) return makeArray();\r\n\tlet i = 0;\r\n\tfor(let x of a) {\r\n\t\tf(x,\"array\",i++,[],\"value at index\");\r\n\t}\r\n\treturn a;\r\n};\r\n\r\nexport const map = f => a => {\r\n\tif(!isMap(a)) return makeMap();\r\n\tlet i = 0;\r\n\tfor(let x of a) {\r\n\t\tf(x,\"map\",i++,[],\"value at key\");\r\n\t}\r\n\treturn a;\r\n};\r\n\r\nexport const item = () => id;\r\n\r\nexport const opt = arg => {\r\n\targ.__optional = true;\r\n\treturn arg;\r\n};\r\n\r\nexport const atomic = () => a => {\r\n\t// boolean / string / numeric\r\n\tlet t = typeof a;\r\n\tif(t === \"string\" || t === \"number\" || t === \"boolean\") return a;\r\n\tconst b = a.constructor;\r\n\treturn isNumeric(a,b) ? a : new b();\r\n};\r\n\r\nconst isNumeric = (a,b) => {\r\n\tswitch(b.name) {\r\n\tcase \"Integer\":\r\n\tcase \"Number\":\r\n\tcase \"Float\":\r\n\tcase \"Decimal\":\r\n\t\treturn true;\r\n\tdefault:\r\n\t\treturn false;\r\n\t}\r\n};\r\n\r\nexport const numeric = () => a => {\r\n\tconst b = a.constructor;\r\n\treturn isNumeric(a,b) ? a : new b();\r\n};\r\n"],"file":"typed.js"}