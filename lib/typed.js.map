{"version":3,"sources":["../src/typed.js"],"names":["check","checked","f","a","t","hasOwnProperty","__wraps","Error","TypeError","constructor","name","errorMessage","i","pos","key","noKey","io","typePart","JSON","stringify","occurrence","test","occ","err","__occurrence","any","id","many","oneOrMore","maybe","zeroOrOne","single","exactlyOne","unwrap","fn","args","s","r","l","o","ret","subscribe","unwrapMaybe","value","next","error","complete","bind","unwrapSingle","c","getStack","orig","prepareStackTrace","_","stack","captureStackTrace","def","st","getFileName","getLineNumber","getColumnNumber","length","array","Array","isArray","forEach","item"],"mappings":"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","sourcesContent":["import { seq, isSeq, create, forEach } from \"./seq\";\r\n\r\nimport { exactlyOne, zeroOrOne, oneOrMore } from \"./seq/card\";\r\n\r\nimport { id, isUndef } from \"./util\";\r\n\r\n// TODO make configurable\r\nconst check = true;\r\n\r\n// we know typed will take a function and test it,\r\n// so we can use the same function here to bind the subscriber\r\n// we should run two tests:\r\n// 1. the cardinality\r\n// 2. the actual type\r\n// furthermore, we should\r\n// 3. unwrap Maybe (allowing nulls or preventing type tests) and Single\r\n// 4. connect types for Flowable to subscriber\r\n\r\n// wrap card + type, if isSeq, don't perform type test, but bind to subscriber:\r\n\r\nconst checked = (f,a) => {\r\n\tconst t = f(a);\r\n\tif(typeof t == \"function\" && t.hasOwnProperty(\"__wraps\")) {\r\n\t\tif(t.__wraps !== a) throw new Error(\"unknown function found\");\r\n\t} else {\r\n\t\tif(a !== t) throw new TypeError(\"Incorrect type: expected \"+t.constructor.name+\", got \"+a.constructor.name);\r\n\t}\r\n\treturn t;\r\n};\r\n\r\n\r\nconst errorMessage = (a,name,i,pos,key) => {\r\n\tif(isUndef(a) || isUndef(name)) return \"Invalid value\\n\";\r\n\tconst noKey = isUndef(key);\r\n\tif(noKey) key = \"argument\";\r\n\tconst io = i < 0 ? \"output\" : key+\" \"+(typeof i == \"string\" ? `\"${i}\"` :  i);\r\n\tconst typePart = noKey ? `for function '${name}' (in ${pos[0]} at line ${pos[1]}, column ${pos[2]})` : `found in ${name}`;\r\n\treturn \"Invalid \"+io+\" *\"+JSON.stringify(a)+\"* \"+typePart + \"\\n\";\r\n};\r\n\r\nexport const occurrence = (test,occ) => f => {\r\n\tconst t = (a,name,i,pos,key) => forEach(a,a => {\r\n\t\ttry {\r\n\t\t\treturn checked(f, test(a));\r\n\t\t} catch(err) {\r\n\t\t\tthrow new Error(errorMessage(a,name,i,pos,key)+err);\r\n\t\t}\r\n\t});\r\n\tt.__occurrence = occ;\r\n\treturn t;\r\n};\r\nexport const any = occurrence(id,1);\r\nexport const many = occurrence(oneOrMore,2);\r\nexport const maybe = occurrence(zeroOrOne,3);\r\nexport const single = occurrence(exactlyOne,4);\r\n\r\nfunction unwrap(fn,args,s,r,name,pos,l,i,o) {\r\n\tif(i === l) {\r\n\t\tconst ret = fn();\r\n\t\treturn o ? seq(ret).subscribe(o) : ret;\r\n\t}\r\n\tconst unwrapMaybe = o => a => {\r\n\t\tlet value = null;\r\n\t\ta.subscribe({\r\n\t\t\tnext(a) {\r\n\t\t\t\tvalue = a;\r\n\t\t\t},\r\n\t\t\terror(err) {\r\n\t\t\t\to.error(err);\r\n\t\t\t},\r\n\t\t\tcomplete() {\r\n\t\t\t\tunwrap(fn.bind(null,value),args,s,r,name,pos,l,i+1,o);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\tconst unwrapSingle = o => a => a.subscribe({\r\n\t\tnext(a) {\r\n\t\t\tunwrap(fn.bind(null,a),args,s,r,name,pos,l,i+1,o);\r\n\t\t},\r\n\t\terror(err) {\r\n\t\t\to.error(err);\r\n\t\t}\r\n\t});\r\n\tconst f = s[i];\r\n\tconst c = f.__occurrence;\r\n\tconst a = check ? f(args[i],name,i,pos) : a;\r\n\tif(isSeq(a)) {\r\n\t\t// when we unwrap we get back an Observable, not a function...\r\n\t\tif(c === 3) {\r\n\t\t\tif(!o) {\r\n\t\t\t\treturn create(o => {\r\n\t\t\t\t\tunwrapMaybe(o)(a);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn unwrapMaybe(o)(a);\r\n\t\t\t}\r\n\t\t} else if(c === 4) {\r\n\t\t\tif(!o) {\r\n\t\t\t\treturn create(o => {\r\n\t\t\t\t\tunwrapSingle(o)(a);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn unwrapSingle(o)(a);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn unwrap(fn.bind(null,a),args,s,r,name,pos,l,i+1,o);\r\n}\r\n\r\n// TODO use separate cross-browser package conditionally\r\nfunction getStack(){\r\n\tvar orig = Error.prepareStackTrace;\r\n\tError.prepareStackTrace = function(_, stack) {\r\n\t\treturn stack;\r\n\t};\r\n\tvar err = new Error;\r\n\tError.captureStackTrace(err);\r\n\tvar stack = err.stack;\r\n\tError.prepareStackTrace = orig;\r\n\treturn stack;\r\n}\r\n\r\nexport const def = (name,s,r,pos) => fn => {\r\n\tif(typeof fn !== \"function\") throw new TypeError(\"Invalid argument for function 'def'\\nExpected a Function, got a \"+fn.constructor.name);\r\n\tif(isUndef(pos)) {\r\n\t\tvar st = getStack()[2];\r\n\t\tpos = [st.getFileName(),st.getLineNumber(), st.getColumnNumber()];\r\n\t}\r\n\tconst f = (...args) => {\r\n\t\tconst ret = unwrap(fn,args,s,r,name,pos,args.length,0);\r\n\t\treturn check ? r(ret,-1,name) : ret;\r\n\t};\r\n\tf.__wraps = fn;\r\n\treturn f;\r\n};\r\n\r\nexport const array = f => a => {\r\n\tif(!Array.isArray(a)) return [];\r\n\ta.forEach((a,i) => {\r\n\t\tf(a,\"array\",i,[],\"value at index\");\r\n\t});\r\n\treturn a;\r\n};\r\n\r\nexport const item = id;\r\n"],"file":"typed.js"}