{"version":3,"sources":["../src/access-streaming.js"],"names":["children","$node","axis","parentNode","childNode","depth","NaN","f","__is_NodeTypeTest","__Accessor","node","name","n","_hasAncestor","maybeAncestor","parent","test","isNaN","isClose","type","filter","Axis","g","__is_Axis","__type","child","$f","cx","map","stepper","bind","self","_axify","$path","concatMap","path","at","substring","select","paths","skipWhile","axes","reduce","changeFn","concatAll"],"mappings":"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","sourcesContent":["import { seq, forEach } from \"./seq\";\r\n\r\nimport { error } from \"./error\";\r\n\r\nimport { element, attribute } from \"./access\";\r\n\r\nexport function children($node, axis) {\r\n\tvar parentNode, childNode, depth = NaN;\r\n\t// move to first childNode if isNaN, or the same depth\r\n\tvar f = axis && axis.f ?\r\n\t\taxis.f.__is_NodeTypeTest ?\r\n\t\t\taxis.f.__Accessor ?\r\n\t\t\t\tnode => axis.f(node) && node.name == axis.f.__Accessor :\r\n\t\t\t\taxis.f :\r\n\t\t\taxis.f :\r\n\t\tn => n;\r\n\tconst _hasAncestor = (node,maybeAncestor) => {\r\n\t\twhile(node.parent) {\r\n\t\t\tif(node.parent == maybeAncestor) return true;\r\n\t\t\tnode = node.parent;\r\n\t\t}\r\n\t};\r\n\tconst test = (node) => {\r\n\t\tif (isNaN(depth)) depth = node.depth;\r\n\t\t// if depth is at node, switch context\r\n\t\t// TODO filter while depth > cxDepth, move cx down while nodetest true\r\n\t\tconst isClose = node.type == 17;\r\n\t\tif(!isClose) {\r\n\t\t\tif (node.depth == depth) {\r\n\t\t\t\tparentNode = node;\r\n\t\t\t\t//console.log(\"init\",node.type,node.name);\r\n\t\t\t} else if(node.parent == parentNode) {\r\n\t\t\t\tif(f(node)) {\r\n\t\t\t\t\tchildNode = node;\r\n\t\t\t\t\t//console.log(\"cx\",node.type,node.name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 1. never emit init\r\n\t\t// 2. emit only cx nodes that pass filter\r\n\t\t// 3. emit only nodes that have cx as ancestor\r\n\t\treturn (isClose ? node.node : node) == parentNode ? false :\r\n\t\t\t(isClose ? node.node : node) == childNode ? true :\r\n\t\t\t\t_hasAncestor(node,childNode);\r\n\t};\r\n\treturn $node.filter(test);\r\n}\r\n\r\nexport function Axis(g, f, type) {\r\n\treturn {\r\n\t\t__is_Axis: true,\r\n\t\t__type: type || 1,\r\n\t\tf: f,\r\n\t\tg: g\r\n\t};\r\n}\r\n\r\nexport function child($f) {\r\n\tvar cx = this;\r\n\treturn seq($f).map(f => {\r\n\t\tvar axis = Axis(void 0, f, 1);\r\n\t\tvar stepper = $node => children.bind(cx || this)($node, axis);\r\n\t\taxis.g = stepper;\r\n\t\treturn axis;\r\n\t});\r\n}\r\n\r\nexport function self($f) {\r\n\treturn seq($f).map(f => {\r\n\t\tvar axis = Axis(void 0, f, 1);\r\n\t\tvar stepper = $node => $node;\r\n\t\taxis.g = stepper;\r\n\t\treturn axis;\r\n\t});\r\n}\r\n\r\nfunction _axify($path) {\r\n\treturn seq($path).concatMap(path => {\r\n\t\tif (!path.__is_Axis) {\r\n\t\t\t// process strings (can this be combined?)\r\n\t\t\tif (typeof path == \"string\") {\r\n\t\t\t\tvar at = /^@/.test(path);\r\n\t\t\t\tif (at) path = path.substring(1);\r\n\t\t\t\treturn at ? attribute(path) : child(element(path));\r\n\t\t\t} else if (typeof path == \"function\") {\r\n\t\t\t\tif (path.__is_NodeTypeTest) return child(path);\r\n\t\t\t\treturn self(path);\r\n\t\t\t} else {\r\n\t\t\t\treturn error(\"XXX\", \"Unknown axis provided\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn seq(path);\r\n\t});\r\n}\r\n\r\nexport function select($node, ...paths) {\r\n\tvar cx = this;\r\n\t$node = seq($node).skipWhile(node => node.type != 1);\r\n\t// make sure the root is a valid context\r\n\r\n\tvar axes = forEach(seq(paths),_axify);\r\n\r\n\t// execute the axis stepping function,\r\n\t// it should now take care of the testing / transformation function\r\n\treturn axes\r\n\t\t.map(path => $node => path.g.bind(cx)($node))\r\n\t\t// update the context state\r\n\t\t.reduce(($node, changeFn) => changeFn($node), $node)\r\n\t\t.concatAll();\r\n}\r\n"],"file":"access-streaming.js"}