{"version":3,"sources":["../src/access-streaming.js"],"names":["children","$node","axis","parentNode","childNode","depth","NaN","f","__is_NodeTypeTest","__Accessor","node","name","n","_hasAncestor","maybeAncestor","parent","test","isNaN","isClose","type","filter","Axis","g","__is_Axis","__type","child","$f","cx","map","stepper","bind","self","_axify","$path","concatMap","path","at","substring","select","paths","skipWhile","axes","reduce","changeFn","concatAll"],"mappings":"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","sourcesContent":["import { seq, forEach } from \"./seq\";\n\nimport { error } from \"./error\";\n\nimport { element, attribute } from \"./access\";\n\nexport function children($node, axis) {\n\tvar parentNode, childNode, depth = NaN;\n\t// move to first childNode if isNaN, or the same depth\n\tvar f = axis && axis.f ?\n\t\taxis.f.__is_NodeTypeTest ?\n\t\t\taxis.f.__Accessor ?\n\t\t\t\tnode => axis.f(node) && node.name == axis.f.__Accessor :\n\t\t\t\taxis.f :\n\t\t\taxis.f :\n\t\tn => n;\n\tconst _hasAncestor = (node,maybeAncestor) => {\n\t\twhile(node.parent) {\n\t\t\tif(node.parent == maybeAncestor) return true;\n\t\t\tnode = node.parent;\n\t\t}\n\t};\n\tconst test = (node) => {\n\t\tif (isNaN(depth)) depth = node.depth;\n\t\t// if depth is at node, switch context\n\t\t// TODO filter while depth > cxDepth, move cx down while nodetest true\n\t\tconst isClose = node.type == 17;\n\t\tif(!isClose) {\n\t\t\tif (node.depth == depth) {\n\t\t\t\tparentNode = node;\n\t\t\t\t//console.log(\"init\",node.type,node.name);\n\t\t\t} else if(node.parent == parentNode) {\n\t\t\t\tif(f(node)) {\n\t\t\t\t\tchildNode = node;\n\t\t\t\t\t//console.log(\"cx\",node.type,node.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 1. never emit init\n\t\t// 2. emit only cx nodes that pass filter\n\t\t// 3. emit only nodes that have cx as ancestor\n\t\treturn (isClose ? node.node : node) == parentNode ? false :\n\t\t\t(isClose ? node.node : node) == childNode ? true :\n\t\t\t\t_hasAncestor(node,childNode);\n\t};\n\treturn $node.filter(test);\n}\n\nexport function Axis(g, f, type) {\n\treturn {\n\t\t__is_Axis: true,\n\t\t__type: type || 1,\n\t\tf: f,\n\t\tg: g\n\t};\n}\n\nexport function child($f) {\n\tvar cx = this;\n\treturn seq($f).map(f => {\n\t\tvar axis = Axis(void 0, f, 1);\n\t\tvar stepper = $node => children.bind(cx || this)($node, axis);\n\t\taxis.g = stepper;\n\t\treturn axis;\n\t});\n}\n\nexport function self($f) {\n\treturn seq($f).map(f => {\n\t\tvar axis = Axis(void 0, f, 1);\n\t\tvar stepper = $node => $node;\n\t\taxis.g = stepper;\n\t\treturn axis;\n\t});\n}\n\nfunction _axify($path) {\n\treturn seq($path).concatMap(path => {\n\t\tif (!path.__is_Axis) {\n\t\t\t// process strings (can this be combined?)\n\t\t\tif (typeof path == \"string\") {\n\t\t\t\tvar at = /^@/.test(path);\n\t\t\t\tif (at) path = path.substring(1);\n\t\t\t\treturn at ? attribute(path) : child(element(path));\n\t\t\t} else if (typeof path == \"function\") {\n\t\t\t\tif (path.__is_NodeTypeTest) return child(path);\n\t\t\t\treturn self(path);\n\t\t\t} else {\n\t\t\t\treturn error(\"XXX\", \"Unknown axis provided\");\n\t\t\t}\n\t\t}\n\t\treturn seq(path);\n\t});\n}\n\nexport function select($node, ...paths) {\n\tvar cx = this;\n\t$node = seq($node).skipWhile(node => node.type != 1);\n\t// make sure the root is a valid context\n\n\tvar axes = forEach(seq(paths),_axify);\n\n\t// execute the axis stepping function,\n\t// it should now take care of the testing / transformation function\n\treturn axes\n\t\t.map(path => $node => path.g.bind(cx)($node))\n\t\t// update the context state\n\t\t.reduce(($node, changeFn) => changeFn($node), $node)\n\t\t.concatAll();\n}\n"],"file":"access-streaming.js"}