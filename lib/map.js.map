{"version":3,"sources":["../src/map.js"],"names":["OrderedMap","ohamt","empty","constructor","prototype","__is_Map","_type","m","kv","append","call","$","$k","$v","len","arguments","length","get","set","isMap","maybe","fromEntries","entries","_create","beginMutation","k","v","endMutation","make","keyEq","x","y","Object","eq","map","a","l","s","merge","Array","isArray","mergeAll","$m","undefined","reduce","pre","cur","keys","contains","has","size","count","forEachEntry","fn","entry","remove","delete"],"mappings":"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","sourcesContent":["import * as ohamt from \"ohamt\";\r\n\r\nimport { isSeq, from, forEach } from \"./seq\";\r\n\r\nimport { isObject } from \"./util\";\r\n\r\n//import { map } from \"./access\";\r\n\r\nimport { error } from \"./error\";\r\n\r\n//import { eq } from \"./op\";\r\n\r\nconst OrderedMap = ohamt.empty.constructor;\r\n\r\nOrderedMap.prototype.__is_Map = true;\r\n\r\nOrderedMap.prototype._type = 6;\r\n\r\nOrderedMap.prototype[\"@@transducer/init\"] = function(){\r\n\treturn ohamt.empty;\r\n};\r\n\r\nOrderedMap.prototype[\"@@transducer/step\"] = function(m,kv) {\r\n\treturn m.append(kv[0],kv[1]);\r\n};\r\n\r\nOrderedMap.prototype[\"@@transducer/result\"] = function(m) {\r\n\treturn m;\r\n};\r\n\r\nOrderedMap.prototype.call = function($,$k,$v) {\r\n\tconst len = arguments.length;\r\n\tif(len == 2) return get(this,$k);\r\n\tif(len == 3) return set(this,$k,$v);\r\n\treturn this;\r\n};\r\n\r\nexport function isMap(maybe){\r\n\treturn !!(maybe && maybe.__is_Map);\r\n}\r\n\r\nexport const fromEntries = (entries, m = _create()) => {\r\n\tm = m.beginMutation();\r\n\tfor(const [k,v] of entries) m = m.set(k,v);\r\n\treturn m.endMutation();\r\n};\r\n\r\nconst _create = () => ohamt.make({\r\n\tkeyEq: (x,y) => x instanceof Object && \"eq\" in x ? x.eq(y) : x === y\r\n});\r\n\r\nexport function map(...a) {\r\n\tvar l = a.length;\r\n\tif (l === 0) {\r\n\t\treturn _create();\r\n\t}\r\n\tif (l == 1) {\r\n\t\tvar s = a[0];\r\n\t\tif (isSeq(s)) return merge(s);\r\n\t\tif (isMap(s)) return s;\r\n\t\tif (isObject(s)) return fromEntries(Object.entries(s));\r\n\t\tif(Array.isArray(s)) return fromEntries(s);\r\n\t\t// TODO VNode conversion + detect tuple\r\n\t\t//if ((0, _access.map)()(s)) return s.toMap();\r\n\t\treturn error(\"XXX\", \"Not a map or tuple\");\r\n\t}\r\n\t// expect a sequence of maps or each argument to be a map\r\n\treturn merge(from(a).mergeAll());\r\n}\r\n\r\nexport function merge($m) {\r\n\tif ($m === undefined) return error(\"XPTY0004\");\r\n\t// assume a sequence of vectors\r\n\treturn $m.reduce((pre, cur) => {\r\n\t\t// TODO force persistent cx\r\n\t\t//if ((0, _access.map)()(cur)) cur = cur.toMap();\r\n\t\tif (!isMap(cur)) {\r\n\t\t\treturn error(\"XPTY0004\", \"One of the items for map:merge is not a map.\");\r\n\t\t}\r\n\t\treturn fromEntries(cur, pre);\r\n\t}, _create());\r\n}\r\n\r\nexport function set(m, k, v) {\r\n\treturn m.set(k,v);\r\n}\r\n\r\nexport function keys(m) {\r\n\treturn m.keys();\r\n}\r\n\r\nexport function contains(m, k) {\r\n\treturn m => m.has(k);\r\n}\r\n\r\nexport function size(m) {\r\n\treturn m.count();\r\n}\r\n\r\nexport function forEachEntry(m, fn) {\r\n\treturn forEach(from(m.entries()),([k,v]) => fn(k, v));\r\n}\r\n\r\nexport function entry(k, v) {\r\n\t// TODO template errors\r\n\treturn fromEntries([[k,v]]);\r\n}\r\n\r\nexport function get(m, k) {\r\n\treturn m.has(k) ? m.get(k) : null;\r\n}\r\n\r\nexport function remove(m, k) {\r\n\treturn m.delete(k);\r\n}\r\n\r\nexport { set as put, map as default };\r\n"],"file":"map.js"}