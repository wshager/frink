{"version":3,"sources":["../src/impl.js"],"names":["and","a","b","or","not","nodeData","node","type","value","instanceOf","minus","neg","round","number","precision","Number","parseFloat","toFixed","floor","Math"],"mappings":";;;;;;;;;;;;AAAO,MAAMA,MAAM,CAACC,CAAD,EAAGC,CAAH,KAASD,KAAKC,CAA1B;;;;AAEA,MAAMC,KAAK,CAACF,CAAD,EAAGC,CAAH,KAASD,KAAKC,CAAzB;;;;AAEA,MAAME,MAAMH,KAAK,CAACA,CAAlB;;;;AAEA,SAASI,QAAT,CAAkBC,IAAlB,EAAwB;AAC9B,QAAMC,OAAOD,KAAKC,IAAlB,CAD8B,CAE9B;;AACA,MAAIA,QAAQ,CAAR,IAAaA,QAAQ,CAAzB,EAA4B;AAC3B,WAAOD,KAAKE,KAAZ;AACA;AACD,C,CAED;AACA;;;AACO,SAASC,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0B;AAChC,SAAOD,aAAaC,CAApB;AACA,C,CAED;AACA;AACA;;;AACO,SAASQ,KAAT,CAAeT,CAAf,EAAkB;AACxB,SAAO,OAAOA,EAAEU,GAAT,IAAgB,UAAhB,GAA6BV,EAAEU,GAAF,EAA7B,GAAuC,CAACV,CAA/C;AACA;AAED;;;;;;;AAKO,SAASW,KAAT,CAAeC,MAAf,EAAsBC,SAAtB,EAAiC;AACvC;AACA;AACA,SAAO,OAAOD,OAAOD,KAAd,IAAuB,UAAvB,GAAoCC,OAAOD,KAAP,EAApC,GAAqDG,OAAOC,UAAP,CAAkBH,OAAOI,OAAP,CAAeH,SAAf,CAAlB,CAA5D;AACA;;AAEM,SAASI,KAAT,CAAejB,CAAf,EAAkB;AACxB,SAAO,OAAOA,EAAEiB,KAAT,IAAkB,UAAlB,GAA+BjB,EAAEiB,KAAF,EAA/B,GAA2CC,KAAKD,KAAL,CAAWjB,CAAX,CAAlD;AACA","sourcesContent":["export const and = (a,b) => a && b;\r\n\r\nexport const or = (a,b) => a || b;\r\n\r\nexport const not = a => !a;\r\n\r\nexport function nodeData(node) {\r\n\tconst type = node.type;\r\n\t// type 2 will only appear in traversal when node is an attr\r\n\tif (type == 2 || type == 3) {\r\n\t\treturn node.value;\r\n\t}\r\n}\r\n\r\n// TODO card = zero-or-more(), but will always return a boolean\r\n// cardinality is taken into account, so the generalized function needs to do that too\r\nexport function instanceOf(a, b) {\r\n\treturn a instanceof b;\r\n}\r\n\r\n// TODO card = zero-or-one(), which will return empty() when zero\r\n// better stick to some generally accepted form of Maybe(a) for these cases?\r\n// more TODO generalize mapping of function names to number methods (perhaps with well-known aliases)\r\nexport function minus(a) {\r\n\treturn typeof a.neg == \"function\" ? a.neg() : -a;\r\n}\r\n\r\n/**\r\n * Round a number\r\n * @param  {[type]} $a [description]\r\n * @return {[type]}    [description]\r\n */\r\nexport function round(number,precision) {\r\n\t// NOTE 'precision' is actually called 'scale'... bad W3C, bad!\r\n\t// TODO get the length of the string representation and use either toPrecision (or toExponential is precision is negative)\r\n\treturn typeof number.round == \"function\" ? number.round() : Number.parseFloat(number.toFixed(precision));\r\n}\r\n\r\nexport function floor(a) {\r\n\treturn typeof a.floor == \"function\" ? a.floor() : Math.floor(a);\r\n}\r\n"],"file":"impl.js"}