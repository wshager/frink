{"version":3,"sources":["../src/impl.js"],"names":["and","a","b","or","not","nodeData","node","type","value","instanceOf","minus","neg","round","number","precision","Number","parseFloat","toFixed","floor","Math"],"mappings":";;;;;;;;;;;;AAAO,MAAMA,GAAG,GAAGC,CAAC,IAAIC,CAAC,IAAID,CAAC,IAAIC,CAA3B;;;;AAEA,MAAMC,EAAE,GAAGF,CAAC,IAAIC,CAAC,IAAID,CAAC,IAAIC,CAA1B;;;;AAEA,MAAME,GAAG,GAAGH,CAAC,IAAI,CAACA,CAAlB;;;;AAEA,SAASI,QAAT,CAAkBC,IAAlB,EAAwB;AAC9B,QAAMC,IAAI,GAAGD,IAAI,CAACC,IAAlB,CAD8B,CAE9B;;AACA,MAAIA,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAI,CAAzB,EAA4B;AAC3B,WAAOD,IAAI,CAACE,KAAZ;AACA;AACD,C,CAED;AACA;;;AACO,SAASC,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0B;AAChC,SAAOD,CAAC,YAAYC,CAApB;AACA,C,CAED;AACA;AACA;;;AACO,SAASQ,KAAT,CAAeT,CAAf,EAAkB;AACxB,SAAO,OAAOA,CAAC,CAACU,GAAT,IAAgB,UAAhB,GAA6BV,CAAC,CAACU,GAAF,EAA7B,GAAuC,CAACV,CAA/C;AACA;AAED;;;;;;;AAKO,SAASW,KAAT,CAAeC,MAAf,EAAsBC,SAAtB,EAAiC;AACvC;AACA;AACA,SAAO,OAAOD,MAAM,CAACD,KAAd,IAAuB,UAAvB,GAAoCC,MAAM,CAACD,KAAP,EAApC,GAAqDG,MAAM,CAACC,UAAP,CAAkBH,MAAM,CAACI,OAAP,CAAeH,SAAf,CAAlB,CAA5D;AACA;;AAEM,SAASI,KAAT,CAAejB,CAAf,EAAkB;AACxB,SAAO,OAAOA,CAAC,CAACiB,KAAT,IAAkB,UAAlB,GAA+BjB,CAAC,CAACiB,KAAF,EAA/B,GAA2CC,IAAI,CAACD,KAAL,CAAWjB,CAAX,CAAlD;AACA","sourcesContent":["export const and = a => b => a && b;\n\nexport const or = a => b => a || b;\n\nexport const not = a => !a;\n\nexport function nodeData(node) {\n\tconst type = node.type;\n\t// type 2 will only appear in traversal when node is an attr\n\tif (type == 2 || type == 3) {\n\t\treturn node.value;\n\t}\n}\n\n// TODO card = zero-or-more(), but will always return a boolean\n// cardinality is taken into account, so the generalized function needs to do that too\nexport function instanceOf(a, b) {\n\treturn a instanceof b;\n}\n\n// TODO card = zero-or-one(), which will return empty() when zero\n// better stick to some generally accepted form of Maybe(a) for these cases?\n// more TODO generalize mapping of function names to number methods (perhaps with well-known aliases)\nexport function minus(a) {\n\treturn typeof a.neg == \"function\" ? a.neg() : -a;\n}\n\n/**\n * Round a number\n * @param  {[type]} $a [description]\n * @return {[type]}    [description]\n */\nexport function round(number,precision) {\n\t// NOTE 'precision' is actually called 'scale'... bad W3C, bad!\n\t// TODO get the length of the string representation and use either toPrecision (or toExponential is precision is negative)\n\treturn typeof number.round == \"function\" ? number.round() : Number.parseFloat(number.toFixed(precision));\n}\n\nexport function floor(a) {\n\treturn typeof a.floor == \"function\" ? a.floor() : Math.floor(a);\n}\n"],"file":"impl.js"}