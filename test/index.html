<html>

<head>
    <script src="../dist/frink.js"></script>
    <style>
        form[name='core'] label, form[name='main'] label {
            display: block;
        }
        .label-text {
            padding: 0 1em;
        }
        .label-invalid {
            outline: medium solid red;
        }
        form[name='main'] {
            padding: 2em;
            border: thin ridge lightslategray;
        }
        body {
            display: flex;
        }
        section {
            flex: 1 1 50%;
        }
        .result {
            flex: 1 1 auto;
        }
        #result {
            width: 100%;
            height: 100%;
        }
    </style>
    <script>
        // TODO create custom form + controls
        // This is a *very* crude prototype of the core form
        const KEY_BACKSLASH = 220;
        const KEY_ENTER = 13;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const KEY_ESCAPE = 27;
        const mapKeyRE = /\.(\w+)$/;
        const listKeyRE = /\[([0-9]+)\]$/;
        const callKeyRE = /\(([0-9]+)\)$/;
        const quotationKeyRE = /{([0-9]+)}$/;
        const elementKeyRE = /<([0-9]+)>$/;
        const typeMap = {
            s: 'String',
            n: 'Number',
            b: 'Boolean',
            l: 'List',
            m: 'Map',
            c: 'Call function',
            q: 'Quotation',
            e: 'Element',
            '-': 'Delete',
            ',': 'Add',
        }
        const atomicInputTypeMap = {
            s: 'text',
            n: 'number',
            b: 'checkbox',
        }
        const customExtensionTypeMap = {
            l: 'x-list',
            m: 'x-map',
            e: 'x-element',
            a: 'x-attribute',
            c: 'x-call',
            q: 'x-quotation'
        }
        const wrapLogger = (fn, name) => (...args) => {
            const ret = fn(...args);
            console.log('calling', fn.name || name, 'args', args, 'ret', ret);
            return ret;
        };
        const set = (obj, value, key) => ({...obj, [key]: value});
        //const append = (arr, value) => [...arr, value];
        const insert = (arr, value, index) => [...arr.slice(0, index), value, ...arr.slice(index + 1)];
        const identity = x => x;
        const formValueNormalizer = ({ name, type, value, checked, dataset }, valueContainer) => (
            value
        );
        function createLabel(name, field) {
            const label = document.createElement('label');
            const text = document.createElement('span');
            text.contentEditable = true;
            text.className = 'label-text';
            text.textContent = name;
            label.appendChild(text);
            label.appendChild(field);
            return label;
        }
        function createAtomicControl(type, name) {
            const control = document.createElement('input');
            control.name = name;
            control.type = atomicInputTypeMap[type];
            control.setAttribute('placeholder', name);
            if(type === 'b') {
                control.value = 'true';
            }
            //control.setAttribute('autocomplete', 'off');
            return control;
        }
        const listKeyFormatter = (name, childKey) => {
            if(!/^[0-9]+$/.test(childKey)) {
                throw new Error('Invalid list key');
            }
            return `${name}[${childKey}]`;
        }
        const mapKeyFormatter = (name, childKey) => {
            if(!childKey) {
                throw new Error('Invalid map key');
            }
            return `${name}.${childKey}`;
        }
        const elementKeyFormatter = (name, childKey) => `${name}<${childKey}>`;
        const callKeyFormatter = (name, childKey) => `${name}(${childKey})`;
        const quotationKeyFormatter = (name, childKey) => `${name}{${childKey}}`;
        const keyFormatterMap = {
            l: listKeyFormatter,
            m: mapKeyFormatter,
            e: elementKeyFormatter,
            c: callKeyFormatter,
            q: quotationKeyFormatter
        };
        const listPostCreateField = (name, field) => {
            return field;
        };
        const mapPostCreateField = (name, field) => {
            const label = createLabel(name, field);
            label.firstElementChild.addEventListener('click', evt => {
                evt.preventDefault();
            });
            label.firstElementChild.addEventListener('input', evt => {
                try {
                    field.name = mapKeyFormatter(name, evt.target.textContent);
                    evt.target.classList.remove('label-invalid');
                } catch(err) {
                    console.log(err);
                    evt.target.classList.add('label-invalid');
                }
            });
            return label;
        };
        const callPostCreateField = (name, field, control) => {
            return field;
        }
        const quotationPostCreateField = callPostCreateField;
        const elementPostCreateField = (name, field) => {
            return field;
        }
        const postCreateFieldMap = {
            l: listPostCreateField,
            m: mapPostCreateField,
            e: elementKeyRE,
            c: callPostCreateField,
            q: quotationPostCreateField
        };
        const x = (name, type, appearance = plain, props = {}) => {
            const node = document.createElement('l3-x');
            node.name = name;
            node.type = type;
            node.props = props;
            node.appearance = appearance;
            return node;
        }
        /*const _l3Structure = l3Type => (name, children, appearance = plain, props = {}) => {
            const node = document.createElement('l3-' + l3Type);
            node.name = name;
            node.props = props;
            node.appearance = appearance;
            children.forEach(child => {
                node.appendChild(child);
            })
            return node;
        };*/
        const _l3Structure = l3Type => (name, children) => {
            const node = _createFormOrStructuredControl(l3Type, name);
            children.forEach(child => {
                node.appendChild(child);
            });
            return node;
        }
        const f = _l3Structure();
        const l = _l3Structure('l');
        const m = _l3Structure('m');
        const c = _l3Structure('c');
        const q = _l3Structure('q');
        const e = _l3Structure('e');
        const a = _l3Structure('a');
        const l3Constructors = {
            f,
            x,
            l,
            m,
            c,
            q,
            e,
            a,
        };
        function _createFormOrStructuredControl(l3Type, name) {
            const isForm = !l3Type;
            const type = isForm ? 'm' : l3Type;
            const customExtensionType = customExtensionTypeMap[type];
            const control = isForm
                ? document.createElement('form', { is: 'x-form' })
                : document.createElement('fieldset', { is: customExtensionType });
            control.name = name;
            control.tabIndex = 0;
            control.autocomplete = 'off';
            return control;
        }
        const createStructuredControl = _createFormOrStructuredControl;
        function createControlByType(l3Type, name, dataType) {
            if(l3Type === 'x') {
                return createAtomicControl(dataType, name);
            }
            return createStructuredControl(l3Type, name, { type: 's' });
        }
        const mapKeyNormalizer = name => {
            if(!mapKeyRE.test(name)) {
                throw new Error(`Incorrectly named property ${name} found in map`);
            }
            return name.match(mapKeyRE)[1];
        };
        const listKeyNormalizer = name => {
            if(!listKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in list`);
            }
            return parseInt(name.match(listKeyRE)[1]);
        }
        const callKeyNormalizer = name => {
            if(!callKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in call argument list`);
            }
            return parseInt(name.match(callKeyRE)[1], 10);
        };
        const quotationKeyNormalizer = name => {
            if(!elementKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in quotation argument list`);
            }
            return parseInt(name.match(quotationKeyRE)[1], 10);
        };
        const elementKeyNormalizer = name => {
            if(!elementKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in element list`);
            }
            return parseInt(name.match(elementKeyRE)[1], 10);
        };
        const keyNormalizerMap = {
            l: listKeyNormalizer,
            m: mapKeyNormalizer,
            e: elementKeyNormalizer,
            c: callKeyNormalizer,
            q: quotationKeyNormalizer
        };
        const callAppender = ({ $name, $args }, value, key) => (
            key === 0
                ? { $name: value, $args }
                : { $name, $args: insert($args, value, key - 1) }
        );
        const elementAppender = ({ $name, $children }, value, key) => (
            key === 0
                ? { $name: value, $children }
                : { $name, $children: insert($children, value, key - 1) }
        );
        const XBase = (SomeHTMLElement, {
            valueContainer = {},
            valueNormalizer = formValueNormalizer,
            keyNormalizer = identity,
            appender = set
        } = {}) => class extends SomeHTMLElement {
            constructor() {
                super();
            }
            static get observedAttributes() { return ["value"]; }

            attributeChangedCallback(name, oldValue, newValue) {
                // TODO
            }

            isParentOf(control) {
                const { parentElement } = control;
                // return true when it's the parent
                if (parentElement.isSameNode(this)) {
                    return true;
                }
                // search for the closest ancestor of the control's parent
                const ancestor = parentElement.closest('fieldset, form', this);
                return ancestor.isSameNode(this);
            }

            get controls() {
                return Array.from(this.elements)
                    .filter(control => control.type !== 'submit' && this.isParentOf(control));
            }

            get value() {
                return this.controls.reduce(
                    (acc, control) => appender(acc, valueNormalizer(control, acc), keyNormalizer(control.name)),
                    valueContainer
                );
            }
            set value(v) {
                Object.entries(v).forEach(([k, v]) => {
                    const elm = this.elements[k];
                    elm.value = v;
                });
                return v;
            }
        }
        class RadioGroup extends HTMLElement {
            constructor() {
                super()
                this._internals = this.attachInternals();
                this._shadowRoot = this.attachShadow({mode: 'open'});
                this._options = [];
            }
            get value() {
                const ret = Array.from(this._shadowRoot.children).find(elm => elm.control.checked);
                return ret.control.value;
            }
            set value(val) {
                const ret = Array.from(this._shadowRoot.children).find(elm => elm.control.value === val);
                ret.control.checked = true;
                return val;
            }
            get options() {
                return this._options;
            }
            set options(val) {
                this._options = val;
                this.render();
            }
            render() {
                if (!this.hasAttribute('tabindex')) {
                    this.tabIndex = 0;
                }
                const root = this._shadowRoot;
                while (root.firstChild) {
                    root.removeChild(root.firstChild);
                }
                this._options.forEach(([k, v]) => {
                    const input = document.createElement('input');
                    const label = document.createElement('label');
                    input.type = 'radio';
                    input.name = 'type';
                    input.value = k;
                    input.dataset.key = k;
                    const text = document.createTextNode(`[${k}] ${v}`);
                    label.appendChild(input);
                    label.appendChild(text);
                    root.appendChild(label);
                });
            }
        }
        customElements.define("radio-group", RadioGroup);
        class XForm extends XBase(HTMLFormElement) {}
        customElements.define("x-form", XForm, { extends: 'form' });
        class XList extends XBase(HTMLFieldSetElement, {
            valueContainer: [],
            keyNormalizer: listKeyNormalizer,
            appender: insert,
        }) {}
        customElements.define("x-list", XList, { extends: 'fieldset' });
        class XMap extends XBase(HTMLFieldSetElement, {
            keyNormalizer: mapKeyNormalizer,
        }) {}
        customElements.define("x-map", XMap, { extends: 'fieldset' });
        class XCall extends XBase(HTMLFieldSetElement, {
            valueContainer: {
                $name: void 0,
                $args: [],
            },
            keyNormalizer: callKeyNormalizer,
            appender: callAppender,
        }) {}
        customElements.define("x-call", XCall, { extends: 'fieldset' });
        class XElement extends XBase(HTMLFieldSetElement, {
            valueContainer: {
                $name: void 0,
                $children: [],
            },
            keyNormalizer: elementKeyNormalizer,
            appender: elementAppender,
        }) {}
        customElements.define("x-element", XElement, { extends: 'fieldset' });
        // control appearences
        const plain = ({l3Type, name, type, ...props}) => root => {
            console.log(props)
            const node = l3Type === 'x'
                ? createAtomicControl(type, name)
                : createStructuredControl(l3Type, name);
            Object.entries(props).forEach(([key, val]) => {
                node[key] = val;
            });
            root.appendChild(node);
        };
        class L3Base extends HTMLElement {
            static get formAssociated() { return true; }

            constructor() {
                super();
                this._internals = this.attachInternals();
                this._shadowRoot = this.attachShadow({mode: 'open'});
                this._appearance = void 0;
                this._props = void 0;
            }

            get form() { return this._internals.form; }

            static get observedAttributes() {
                return ['name', 'type', 'value'];
            }
            connectedCallback() {
            }
            focus() {
                let child = this._shadowRoot;
                while(child && !child.focus) {
                    child = child.firstElementChild;
                }
                child && child.focus();
            }
            render() {
                const root = this._shadowRoot;
                while (root.firstChild) {
                    root.removeChild(root.firstChild);
                }
                this._appearance({
                    l3Type: this._l3Type,
                    ...Array.from(this.attributes).reduce((acc, v) => {
                        if(['appearance', 'props'].includes(v.name)) {
                            return acc;
                        }
                        acc[v.name] = v.textContent;
                        return acc;
                    }, {}),
                    ...this._props
                })(this._shadowRoot);
            }
            attributeChangedCallback(name, oldval, newval) {
                console.log('L3Base', name, oldval, newval);
            }
            get l3Type() {
                return this._l3Type;
            }
            get type() {
                return this.getAttribute('type');
            }
            set type(val) {
                return this.setAttribute('type', val);
            }
            get appearance() {
                return this._appearance;
            }

            set appearance(val) {
                // TODO sanitize #+qname
                this.setAttribute('appearance', '#'+val.name);
                this._appearance = val;
                this.render();
                return val;
            }

            get props() {
                return this._props;
            }

            set props(val) {
                this.setAttribute('props', JSON.stringify(val));
                return this._props = val;
            }

            get name() {
                return this.getAttribute('name');
            }

            set name(val) {
                return this.setAttribute('name', val);
            }

            get value() {
                return this._shadowRoot.firstElementChild.value;
            }

            set value(val) {
                return this._shadowRoot.firstElementChild.value = val;
            }
        }
        // TODO validation
        class L3Form extends L3Base {
            constructor() {
                super();
            }
        }
        customElements.define('l3-form', L3Form);
        class L3Text extends L3Base {
            constructor() {
                super();
                this._l3Type = 'x';
            }
            _coerce(val) {
                const typeMap = {
                    n: Number,
                };
                const type = this.getAttribute("type");
                const coercion = typeMap[type] || String;
                return coercion(val);
            }
            get value() {
                const node = this._shadowRoot.firstElementChild;
                if(this.getAttribute('appearance') === '#plain' && this.type === 'b') {
                    return node.checked;
                }
                return this._coerce(node.value);
            }
            set value(val) {
                const node = this._shadowRoot.firstElementChild;
                if(this.getAttribute('appearance') === '#plain') {
                    if(this.type === 'b') {
                        return node.checked = val;
                    }
                }
                return node.value = String(val);
            }
        }
        customElements.define('l3-text', L3Text);
        class L3List extends L3Base {
            constructor() {
                super();
                this._l3Type = 'l';
            }
        }
        customElements.define('l3-list', L3List);
        class L3Map extends L3Base {
            constructor() {
                super();
                this._l3Type = 'm';
            }
        }
        customElements.define('l3-map', L3Map);
        
        class L3Call extends L3Base {
            constructor() {
                super();
                this._l3Type = 'c';
            }
        }
        customElements.define('l3-call', L3Call);
        
        class L3Element extends L3Base {
            constructor() {
                super();
                this._l3Type = 'e';
            }
        }
        customElements.define('l3-element', L3Element);
        
        class L3Attribute extends L3Base {
            constructor() {
                super();
                this._l3Type = 'a';
            }
        }
        customElements.define('l3-attribute', L3Attribute);
        
        class L3Quotation extends L3Base {
            constructor() {
                super();
                this._l3Type = 'q';
            }
        }
        customElements.define('l3-quotation', L3Quotation);
        
        class L3X extends L3Text {}
        customElements.define('l3-x', L3X);
        class L3L extends L3List {}
        customElements.define('l3-l', L3L);
        class L3M extends L3Map {}
        customElements.define('l3-m', L3M);
        class L3C extends L3Call {}
        customElements.define('l3-c', L3C);
        class L3E extends L3Element {}
        customElements.define('l3-e', L3E);
        class L3A extends L3Attribute {}
        customElements.define('l3-a', L3A);
        class L3Q extends L3Quotation {}
        customElements.define('l3-q', L3Q);
        const radioGroup = ({options, value}) => mountpoint => {
            const node = document.createElement('radio-group');
            node.options = options;
            node.value = value;
            mountpoint.appendChild(node);
        }
        function getL3TypeOrDataType(elm) {
            const l3Type = elm.l3Type;
            if(!l3Type) {
                return 'm';
            }
            if(l3Type !== 'x') {
                return l3Type;
            }
            return elm.type;
        }
    </script>
</head>

<body>
    <section id="mountpoint">
    </section>
    <section class="result">
        <pre id="result"/>
    </section>
    <datalist id="calls">
        <option value="equals">
        <option value="not">
        <option value="greater-than">
        <option value="less-then">
        <option value="and">
    </datalist>
    <script>
        // TODO use L3 DOM
        // The intent is NOT to use web components, but only the 'is' attribute
        // so that this form can be rendered on a server *and still work* (numbers and booleans should still be cast)
        // The interactive tree will be translated, and simply contains l3 elements
        // Any attributes may be provided as any data structure, so it would be possible to
        // e.g. provide a enum constraint of an element as a list
        const main = f('main', [x('field1', 's')]);
        const core = f('core', [
            x('active', 'b'),
            x('type', 's', radioGroup, { options: Object.entries(typeMap), value: 's' })
        ]);
        const mountpoint = document.getElementById('mountpoint');
        mountpoint.appendChild(main);
        mountpoint.appendChild(core);
        main.addEventListener('input', function (evt) {
            console.log(this.value);
            document.getElementById('result').textContent = JSON.stringify(this.value, null, 4);
        });
        
        const captureBackSlash = (code, state) => {
            const isBackSlash = code === KEY_BACKSLASH;
            if (isBackSlash) {
                state.active = true;
            }
            return state;
        };
        const jumpState = {selected: void 0};
        function coreChangeHandler(evt) {
            if(evt.target.name === 'active') {
                // if this was triggered by inactivating
                if(jumpState.selected) {
                    coreBlurHandler();
                }
            } else {
                evt.preventDefault();
                core.value = {
                    ...core.value,
                    active: false
                };
                const {selected} = jumpState;
                cleanCore();
                emitCoreChange(core.value, selected);
            }
        }
        function insertChildControl(type, selected, parent) {
            const parentType = getL3TypeOrDataType(parent);
            if(parentType === 'm') {
                parent.controlCount = parent.controls.length;
            }
            const key = parentType === 'm'
                ? 'field' + (++parent.controlCount)
                : parent.controls.length; // FIXME rename all children
            const name = parent.isSameNode(selected.form) ? key : keyFormatterMap[parentType](parent.name, key);
            const control = createControlByType(type, name, parentType);
            const child = postCreateFieldMap[parentType](key, control);
            parent.insertBefore(child, selected.nextSibling);
            control.focus();
        }
        function emitCoreChange({type}, selected) {
            console.log('emitCoreChange', type);
            const form = selected.form;
            if(!form) {
                return;
            }
            const l3Type = atomicInputTypeMap[type] ? 'x' : type;
            let parent = selected.closest('fieldset, form', form);
            const state = parent.value;
            if(type === '-') {
                if(Object.keys(state).length === 1) {
                    return alert('Can not remove this control as it is the only one in this parent');
                }
                const next = selected.nextElementSibling || selected.previousElementSibling;
                next && next.focus();
                selected.remove();
            } else if(type === ',') {
                // append new parent control
                insertChildControl('s', selected, parent);
            } else {
                if(getL3TypeOrDataType(selected) === type) {
                    return;
                }
                const parentType = getL3TypeOrDataType(parent);
                if(parentType === 'c' || parentType === 'e') {
                    const keyNormalizer = keyNormalizerMap[parentType];
                    const index = keyNormalizer(selected.name);
                    if(index === 0) {
                        return alert('Can not change type of the $name control for '+typeMap[parentType]);
                    }
                }
                if(selected.value && !confirm('Are you sure want to change the type of this control? The value will be discarded')) {
                    return;
                }
                console.log(`change type from ${selected.type} to ${type} in parent ${parentType}`);
                // FIXME selected.name is the path
                const { name } = selected;
                const defaultChildName = type === 'm'
                    ? defaultChild.name || 'field1'
                    : 0;
                const defaultChildKey = keyFormatterMap[type](name, defaultChildName);
                console.log(defaultChildKey);
                const field = x(defaultChildKey, 's');
                // TODO move to appearance
                //const child = postCreateFieldMap[type](defaultChildName, field);
                const control = l3Constructors[l3Type](name, l3Type === 'x' ? type : [field]);
                //const node = postCreateFieldMap[parentType](key, control);
                const node = control;
                parent.insertBefore(node, selected);
                selected.remove();
                if(type === 'l' || type === 'm' || type === 'c' || type === 'e') {
                    control.controls[0].focus();
                } else {
                    control.focus();
                }
            }
        }
        function cleanCore() {
            core.removeEventListener("keydown", coreKeyDownHandler);
            //core.removeEventListener("focusout", coreBlurHandler);
            //core.removeEventListener("submit", coreSubmitHandler);
            main.addEventListener("keydown", mainKeyDownHandler);
            jumpState.selected.focus();
            jumpState.selected = void 0;
        }
        function coreBlurHandler(evt) {
            core.value = {
                type: getL3TypeOrDataType(jumpState.selected),
                active: false
            };
            cleanCore();
        }
        function coreKeyDownHandler(evt) {
            const code = evt.keyCode;
            console.log('coreKeyDownHandler', code)
            const controls = this.controls;
            const isEnter = code === KEY_ENTER;
            const isCancelKey = code === KEY_ESCAPE || code === KEY_TAB || code === KEY_BACKSLASH;
            if(isCancelKey || isEnter) {
                if(isEnter) {
                    coreChangeHandler(evt);
                } else {
                    coreBlurHandler(evt);
                }
            } else {
                const isDelete = code === KEY_DELETE;
                const key = isDelete ? '-' : evt.key;
                const typeControl = controls.find(c => c.name === 'type');
                if(typeMap[key]) {
                    typeControl.value = key;
                    // update immediately
                    coreChangeHandler(evt);
                }
            }
        }
        function mainKeyDownHandler(evt) {
            const state = captureBackSlash(evt.keyCode, core.value);
            const selected = document.activeElement;
            if (state.active) {
                evt.preventDefault();
                jumpState.selected = selected;
                // TODO infer type from control (until we have custom controls)
                const type = getL3TypeOrDataType(selected);
                const typeControl = Array.from(core.controls).find(elm => {
                    return elm.name === 'type';
                });
                core.value = {
                    active: true,
                    type,
                }
                typeControl.focus();
                main.removeEventListener("keydown", mainKeyDownHandler);
                //core.addEventListener("focusout", coreBlurHandler);
                //core.addEventListener("submit", coreSubmitHandler);
                core.addEventListener("change", coreChangeHandler);
                core.addEventListener("keydown", coreKeyDownHandler);
            }
        }
        main.addEventListener("keydown", mainKeyDownHandler);
        main.controls[0].focus();
    </script>
</body>

</html>