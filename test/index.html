<html>

<head>
    <script src="../dist/frink.js"></script>
    <style>
        form[name='core'] label, form[name='main'] label {
            display: block;
        }
        .label-text {
            padding: 0 1em;
        }
        .label-invalid {
            outline: thin normal red;
        }
        form[name='main'] {
            padding: 2em;
            border: thin ridge lightslategray;
        }
        form[name='main']:focus, input:focus, fieldset:focus {
            /* FIXME create custom component styles leaving default focus outline as-is */
            outline: normal ridge -webkit-focus-ring-color;
        }
        body {
            display: flex;
        }
        section {
            flex: 1 1 50%;
        }
        .result {
            flex: 1 1 auto;
        }
        #result {
            width: 100%;
            height: 100%;
        }
    </style>
    <script>
        // TODO create custom form + controls
        // This is a *very* crude prototype of the core form
        const KEY_BACKSLASH = 220;
        const KEY_ENTER = 13;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const KEY_ESCAPE = 27;
        const mapKeyRE = /\.(\w+)$/;
        const listKeyRE = /\[([0-9]+)\]$/;
        const callKeyRE = /\(([0-9]+)\)$/;
        const quotationKeyRE = /{([0-9]+)}$/;
        const elementKeyRE = /<([0-9]+)>$/;
        const typeMap = {
            s: 'String',
            n: 'Number',
            b: 'Boolean',
            l: 'List',
            m: 'Map',
            c: 'Call function',
            q: 'Quotation',
            e: 'Element',
            '-': 'Delete',
            ',': 'Add',
        }
        const atomicInputTypeMap = {
            s: 'text',
            n: 'number',
            b: 'checkbox',
        }
        const customExtensionTypeMap = {
            l: 'x-list',
            m: 'x-map',
            e: 'x-element',
            c: 'x-call',
            q: 'x-quotation'
        }
        const wrapLogger = (fn, name) => (...args) => {
            const ret = fn(...args);
            console.log('calling', fn.name || name, 'args', args, 'ret', ret);
            return ret;
        };
        const set = (obj, value, key) => ({...obj, [key]: value});
        //const append = (arr, value) => [...arr, value];
        const insert = (arr, value, index) => [...arr.slice(0, index), value, ...arr.slice(index + 1)];
        const identity = x => x;
        const formValueNormalizer = ({ name, type, value, checked, dataset }, valueContainer) => (
            type === 'checkbox'
                ? checked
                : type === 'radio'
                    ? checked ? value : valueContainer[name]
                    : dataset.type === 'n'
                        ? parseFloat(value)
                        : value 
        );
        function createLabel(name, field) {
            const label = document.createElement('label');
            const text = document.createElement('span');
            text.contentEditable = true;
            text.className = 'label-text';
            text.textContent = name;
            label.appendChild(text);
            label.appendChild(field);
            return label;
        }
        function createAtomicControl(type, name) {
            const control = document.createElement('input');
            control.name = name;
            control.type = atomicInputTypeMap[type];
            control.dataset.type = type;
            control.setAttribute('placeholder', name);
            if(type === 'b') {
                control.value = 'true';
            }
            //control.setAttribute('autocomplete', 'off');
            return control;
        }
        const listKeyFormatter = (name, childKey) => {
            if(!/^[0-9]+$/.test(childKey)) {
                throw new Error('Invalid list key');
            }
            return `${name}[${childKey}]`;
        }
        const mapKeyFormatter = (name, childKey) => {
            if(!childKey) {
                throw new Error('Invalid map key');
            }
            return `${name}.${childKey}`;
        }
        const elementKeyFormatter = (name, childKey) => `${name}<${childKey}>`;
        const callKeyFormatter = (name, childKey) => `${name}(${childKey})`;
        const quotationKeyFormatter = (name, childKey) => `${name}{${childKey}}`;
        const keyFormatterMap = {
            l: listKeyFormatter,
            m: mapKeyFormatter,
            e: elementKeyFormatter,
            c: callKeyFormatter,
            q: quotationKeyFormatter
        };
        const listPostCreateField = (name, field) => {
            return field;
        };
        const mapPostCreateField = (name, field) => {
            const label = createLabel(name, field);
            label.firstElementChild.addEventListener('click', evt => {
                evt.preventDefault();
            });
            label.firstElementChild.addEventListener('input', evt => {
                try {
                    field.name = mapKeyFormatter(name, evt.target.textContent);
                    evt.target.classList.remove('label-invalid');
                } catch(err) {
                    console.log(err);
                    evt.target.classList.add('label-invalid');
                }
            });
            return label;
        };
        const callPostCreateField = (name, field, control) => {
            return field;
        }
        const quotationPostCreateField = callPostCreateField;
        const elementPostCreateField = (name, field) => {
            return field;
        }
        const postCreateFieldMap = {
            l: listPostCreateField,
            m: mapPostCreateField,
            e: elementKeyRE,
            c: callPostCreateField,
            q: quotationPostCreateField
        };
        function _createFormOrStructuredControl(typeOrNull, name, defaultChild) {
            const isForm = typeOrNull === null;
            const type = isForm ? 'm' : typeOrNull;
            const customExtensionType = customExtensionTypeMap[type];
            const control = isForm
                ? document.createElement('form', { is: 'x-form' })
                : document.createElement('fieldset', { is: customExtensionType });
            control.name = name;
            control.tabIndex = 0;
            control.autocomplete = 'off';
            control.dataset.type = type;
            const defaultChildName = type === 'm'
                ? defaultChild.name || 'field1'
                : 0;
            const key = isForm
                ? defaultChildName
                : keyFormatterMap[type](name, defaultChildName);
            const field = createControlByType(defaultChild.type, key);
            const child = postCreateFieldMap[type](defaultChildName, field);
            control.appendChild(child);
            return control;
        }
        const createForm = _createFormOrStructuredControl.bind(null, null);
        const createStructuredControl = _createFormOrStructuredControl;
        function createControlByType(type, name, parentType) {
            switch(type) {
                case 's':
                case 'n':
                case 'b': {
                    return createAtomicControl(type, name);
                }
                case 'l': 
                case 'm': 
                case 'c': 
                case 'e':
                case 'q': {
                    return createStructuredControl(type, name, { type: 's' });
                }
            }
        }
        const mapKeyNormalizer = name => {
            if(!mapKeyRE.test(name)) {
                throw new Error(`Incorrectly named property ${name} found in map`);
            }
            return name.match(mapKeyRE)[1];
        };
        const listKeyNormalizer = name => {
            if(!listKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in list`);
            }
            return parseInt(name.match(listKeyRE)[1]);
        }
        const callKeyNormalizer = name => {
            if(!callKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in call argument list`);
            }
            return parseInt(name.match(callKeyRE)[1], 10);
        };
        const quotationKeyNormalizer = name => {
            if(!elementKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in quotation argument list`);
            }
            return parseInt(name.match(quotationKeyRE)[1], 10);
        };
        const elementKeyNormalizer = name => {
            if(!elementKeyRE.test(name)) {
                throw new Error(`Incorrectly named item ${name} found in element list`);
            }
            return parseInt(name.match(elementKeyRE)[1], 10);
        };
        const keyNormalizerMap = {
            l: listKeyNormalizer,
            m: mapKeyNormalizer,
            e: elementKeyNormalizer,
            c: callKeyNormalizer,
            q: quotationKeyNormalizer
        };
        const callAppender = ({ $name, $args }, value, key) => (
            key === 0
                ? { $name: value, $args }
                : { $name, $args: insert($args, value, key - 1) }
        );
        const elementAppender = ({ $name, $children }, value, key) => (
            key === 0
                ? { $name: value, $children }
                : { $name, $children: insert($children, value, key - 1) }
        );
        const XBase = (SomeHTMLElement, {
            valueContainer = {},
            valueNormalizer = formValueNormalizer,
            keyNormalizer = identity,
            appender = set
        } = {}) => class extends SomeHTMLElement {
            constructor() {
                super();
            }
            static get observedAttributes() { return ["value"]; }

            attributeChangedCallback(name, oldValue, newValue) {
                // TODO
            }

            isParentOf(control) {
                const { parentElement } = control;
                // return true when it's the parent
                if (parentElement.isSameNode(this)) {
                    return true;
                }
                // search for the closest ancestor of the control's parent
                const ancestor = parentElement.closest('fieldset, form', this);
                return ancestor.isSameNode(this);
            }

            get controls() {
                return Array.from(this.elements)
                    .filter(control => control.type !== 'submit' && this.isParentOf(control));
            }

            get value() {
                return this.controls.reduce(
                    (acc, control) => appender(acc, valueNormalizer(control, acc), keyNormalizer(control.name)),
                    valueContainer
                );
            }
            set value(v) {
                Object.entries(v).forEach(([k, v]) => {
                    const elm = this.elements[k];
                    if(elm.type === 'checkbox') {
                        elm.checked = v;
                    } else {
                        elm.value = v;
                    }
                });
                return v;
            }
        }
        
        class XForm extends XBase(HTMLFormElement) {}
        customElements.define("x-form", XForm, { extends: 'form' });
        class XList extends XBase(HTMLFieldSetElement, {
            valueContainer: [],
            keyNormalizer: listKeyNormalizer,
            appender: insert,
        }) {}
        customElements.define("x-list", XList, { extends: 'fieldset' });
        class XMap extends XBase(HTMLFieldSetElement, {
            keyNormalizer: mapKeyNormalizer,
        }) {}
        customElements.define("x-map", XMap, { extends: 'fieldset' });
        class XCall extends XBase(HTMLFieldSetElement, {
            valueContainer: {
                $name: void 0,
                $args: [],
            },
            keyNormalizer: callKeyNormalizer,
            appender: callAppender,
        }) {}
        customElements.define("x-call", XCall, { extends: 'fieldset' });
        class XElement extends XBase(HTMLFieldSetElement, {
            valueContainer: {
                $name: void 0,
                $children: [],
            },
            keyNormalizer: elementKeyNormalizer,
            appender: elementAppender,
        }) {}
        customElements.define("x-element", XElement, { extends: 'fieldset' });
        // control appearences
        function radiogroup({ options }) {
            const group = document.createElement('div');
            options.forEach(([k, v]) => {
                const input = document.createElement('input');
                const label = document.createElement('label');
                input.type = 'radio';
                input.name = 'type';
                input.value = k;
                input.dataset.key = k;
                const text = document.createTextNode(`[${k}] ${v}`);
                label.appendChild(input);
                label.appendChild(text);
                group.appendChild(label);
            });
            return group;
        }
    </script>
</head>

<body>
    <section id="mountpoint">
    </section>
    <section class="result">
        <pre id="result"/>
    </section>
    <datalist id="calls">
        <option value="equals">
        <option value="not">
        <option value="greater-than">
        <option value="less-then">
        <option value="and">
    </datalist>
    <script>
        // TODO use L3 DOM
        // The intent is NOT to use web components, but only the 'is' attribute
        // so that this form can be rendered on a server *and still work* (numbers and booleans should still be cast)
        // The interactive tree will be translated, and simply contains l3 elements
        // Any attributes may be provided as any data structure, so it would be possible to
        // e.g. provide a enum constraint of an element as a list
        const main = createForm('main', { type: 's' });
        const core = createForm('core', {type: 'b', name: 'active'});
        core.appendChild(radiogroup({ options: Object.entries(typeMap) }));
        const mountpoint = document.getElementById('mountpoint');
        mountpoint.appendChild(main);
        mountpoint.appendChild(core);
        main.addEventListener('input', function (evt) {
            console.log(this.value);
            document.getElementById('result').textContent = JSON.stringify(this.value, null, 4);
        });
        
        const captureBackSlash = (code, state) => {
            const isBackSlash = code === KEY_BACKSLASH;
            if (isBackSlash) {
                state.active = true;
            }
            return state;
        };
        const jumpState = {selected: void 0};
        function coreChangeHandler(evt) {
            if(evt.target.name === 'active') {
                // if this was triggered by inactivating
                if(jumpState.selected) {
                    coreBlurHandler();
                }
            } else {
                evt.preventDefault();
                core.value = {
                    ...core.value,
                    active: false
                };
                const {selected} = jumpState;
                cleanCore();
                emitCoreChange(core.value, selected);
            }
        }
        function insertChildControl(type, selected, parent) {
            const parentType = parent.dataset.type;
            if(parentType === 'm') {
                parent.controlCount = parent.controls.length;
            }
            const key = parentType === 'm'
                ? 'field' + (++parent.controlCount)
                : parent.controls.length; // FIXME rename all children
            const name = parent.isSameNode(selected.form) ? key : keyFormatterMap[parentType](parent.name, key);
            const control = createControlByType(type, name, parentType);
            const child = postCreateFieldMap[parentType](key, control);
            parent.insertBefore(child, selected.nextSibling);
            control.focus();
        }
        function emitCoreChange({type}, selected) {
            const form = selected.form;
            if(!form) {
                return;
            }
            let parent = selected.closest('fieldset, form', form);
            const state = parent.value;
            if(type === '-') {
                if(Object.keys(state).length === 1) {
                    return alert('Can not remove this control as it is the only one in this parent');
                }
                const next = selected.nextElementSibling || selected.previousElementSibling;
                next && next.focus();
                selected.remove();
            } else if(type === ',') {
                // append new parent control
                insertChildControl('s', selected, parent);
            } else {
                if(selected.dataset.type === type) {
                    return;
                }
                const parentType = parent.dataset.type;
                if(parentType === 'c' || parentType === 'e') {
                    const keyNormalizer = keyNormalizerMap[parentType];
                    const index = keyNormalizer(selected.name);
                    if(index === 0) {
                        return alert('Can not change type of the $name control for '+typeMap[parentType]);
                    }
                }
                if(selected.value && !confirm('Are you sure want to change the type of this control? The value will be discarded')) {
                    return;
                }
                console.log(`change type from ${selected.type} to ${type} in parent ${parentType}`);
                const control = createControlByType(type, selected.name, parentType);
                const refNode = parentType === 'm' ? selected.parentElement : selected;
                // FIXME selected.name is the path
                const { name } = selected;
                const key = parent.isSameNode(form)
                    ? name
                    : keyNormalizerMap[parentType](name);
                const node = postCreateFieldMap[parentType](key, control);
                parent.insertBefore(node, refNode);
                refNode.remove();
                if(type === 'l' || type === 'm' || type === 'c' || type === 'e') {
                    control.controls[0].focus();
                } else {
                    control.focus();
                }
            }
        }
        function cleanCore() {
            core.removeEventListener("keydown", coreKeyDownHandler);
            //core.removeEventListener("focusout", coreBlurHandler);
            //core.removeEventListener("submit", coreSubmitHandler);
            main.addEventListener("keydown", mainKeyDownHandler);
            jumpState.selected.focus();
            jumpState.selected = void 0;
        }
        function coreBlurHandler(evt) {
            core.value = {
                type: jumpState.selected.dataset.type,
                active: false
            };
            cleanCore();
        }
        function coreKeyDownHandler(evt) {
            const code = evt.keyCode;
            const controls = this.controls;
            const isEnter = code === KEY_ENTER;
            const isCancelKey = code === KEY_ESCAPE || code === KEY_TAB || code === KEY_BACKSLASH;
            if(isCancelKey || isEnter) {
                if(isEnter) {
                    coreChangeHandler(evt);
                } else {
                    coreBlurHandler(evt);
                }
            } else {
                const isDelete = code === KEY_DELETE;
                const key = isDelete ? '-' : evt.key;
                const keyBound = controls.find(c => c.dataset.key === key);
                if(keyBound) {
                    keyBound.checked = true;
                    keyBound.focus();
                    // update immediately
                    coreChangeHandler(evt);
                }
            }
        }
        function mainKeyDownHandler(evt) {
            const state = captureBackSlash(evt.keyCode, core.value);
            const selected = document.activeElement;
            if (state.active) {
                evt.preventDefault();
                jumpState.selected = selected;
                // TODO infer type from control (until we have custom controls)
                const type = selected.dataset.type;
                const typeControl = Array.from(core.controls).find(elm => elm.name === 'type' && elm.value === type);
                if(!typeControl) {
                    throw new TypeError('Could not find control for type ' + type);
                }
                core.value = {
                    active: true,
                    type,
                }
                typeControl.focus();
                main.removeEventListener("keydown", mainKeyDownHandler);
                //core.addEventListener("focusout", coreBlurHandler);
                //core.addEventListener("submit", coreSubmitHandler);
                core.addEventListener("change", coreChangeHandler);
                core.addEventListener("keydown", coreKeyDownHandler);
            }
        }
        main.addEventListener("keydown", mainKeyDownHandler);
        main.controls[0].focus();
    </script>
</body>

</html>