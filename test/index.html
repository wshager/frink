<html>

<head>
    <script src="../dist/frink.js"></script>
    <style>
        form[name='core'] label {
            display: block;
        }
        form[name='main'] input {
            display: block;
        }
        input:focus, fieldset:focus {
            /* FIXME create custom component styles leaving default focus outline as-is */
            outline: normal ridge -webkit-focus-ring-color;
        }
    </style>
    <script>
        class XForm extends HTMLFormElement {
            constructor() {
                super();
            }

            static get observedAttributes() { return ["value"]; }

            attributeChangedCallback(name, oldValue, newValue) {
                // TODO
            }

            get value() {
                return Array.from(this.elements).reduce((acc, control) => {
                    const { name, type, value, checked, parentElement } = control;
                    const isParent = parentElement.isSameNode(this) || (parentElement.nodeName === 'LABEL' && parentElement.parentElement.isSameNode(this));
                    if(type === 'submit' || !isParent) {
                        console.log(control)
                        return acc;
                    }
                    const normalizedValue = type === 'checkbox'
                        ? checked
                        : type === 'radio'
                            ? checked ? value : acc[name]
                            : value;
                    acc[name] = normalizedValue;
                    return acc;
                }, {});
            }
            set value(v) {
                Object.entries(v).forEach(([k, v]) => {
                    const elm = this.elements[k];
                    if(elm.type === 'checkbox') {
                        elm.checked = v;
                    } else {
                        elm.value = v;
                    }
                });
                return v;
            }
        }
        customElements.define("x-form", XForm, { extends: 'form' });
        class XList extends HTMLFieldSetElement {
            constructor() {
                super();
                this._listKeyRE = /(\[[0-9]*\])+$/;
            }

            static get observedAttributes() { return ["value"]; }

            attributeChangedCallback(name, oldValue, newValue) {
                // TODO
            }

            get value() {
                return Array.from(this.elements).reduce((acc, control) => {
                    const { name, type, value, checked } = control;
                    if(type === 'submit' || !control.parentElement.isSameNode(this)) {
                        return acc;
                    }
                    const normalizedValue = type === 'checkbox'
                        ? checked
                        : type === 'radio'
                            ? checked ? value : acc[name]
                            : value;
                    if(this._listKeyRE.test(name)) {
                        const key = name.replace(this._listKeyRE, '');
                        acc.push(normalizedValue);
                    } else {
                        throw new Error('Incorrectly named item found in list');
                    }
                    return acc;
                }, []);
            }
            set value(v) {
                // TODO
            }
        }
        customElements.define("x-list", XList, { extends: 'fieldset' });
        class XMap extends HTMLFieldSetElement {
            constructor() {
                super();
                this._mapKeyRE = /\[(\w+)\]$/;
            }

            static get observedAttributes() { return ["value"]; }

            attributeChangedCallback(name, oldValue, newValue) {
                // TODO
            }

            get value() {
                return Array.from(this.elements).reduce((acc, control) => {
                    const { name, type, value, checked } = control;
                    if(type === 'submit' || !control.parentElement.isSameNode(this)) {
                        return acc;
                    }
                    const normalizedValue = type === 'checkbox'
                        ? checked
                        : type === 'radio'
                            ? checked ? value : acc[name]
                            : value;
                    if(this._mapKeyRE.test(name)) {
                        const key = name.match(this._mapKeyRE)[1];
                        acc[key] = normalizedValue;
                    } else {
                        throw new Error('Incorrectly named property found in map');
                    }
                    return acc;
                }, {});
            }
            set value(v) {
                // TODO
            }
        }
        customElements.define("x-map", XMap, { extends: 'fieldset' });
        /*
        class XBoolean extends HTMLElement {
            static get formAssociated() { return true; }

            constructor() {
                super();
                this._internals = this.attachInternals();
                this._checked = false;
                this.addEventListener('click', this._onClick.bind(this));
            }

            get form() { return this._internals.form; }
            get name() { return this.getAttribute('name'); }
            get type() { return this.localName; }

            get checked() { return this._checked; }
            set checked(flag) {
                this._checked = !!flag;
                this._internals.setFormValue(this._checked);
            }

            _onClick(event) {
                this.checked = !this._checked;
            }
        }
        customElements.define('x-boolean', XBoolean);
        */
    </script>
</head>

<body>
    <form data-type="m" is="x-form" name="main">
        <input data-type="s" name="field1">
        <input data-type="s" name="field2">
    </form>
    <form is="x-form" name="core">
        <input type="checkbox" name="active">
    </form>
    <script>
        // TODO create custom form + controls
        // This is a *very* crude prototype of the core form
        var main = document.forms.main;
        main.addEventListener('input', function (evt) {
            console.log(this.value);
        });
        const typeMap = {
            s: 'String',
            n: 'Number',
            b: 'Boolean',
            l: 'List',
            m: 'Map',
            '-': 'Delete',
            ',': 'Add',
        }
        const atomicInputTypeMap = {
            s: 'text',
            n: 'number',
            b: 'checkbox',
        }
        const core = document.forms.core;
        // TODO use L3 DOM
        Object.entries(typeMap).forEach(([k, v]) => {
            const input = document.createElement('input');
            const label = document.createElement('label');
            input.type = 'radio';
            input.name = 'type';
            input.value = k;
            input.dataset.key = k;
            const text = document.createTextNode(`[${k}] ${v}`);
            label.appendChild(input);
            label.appendChild(text);
            core.appendChild(label);
        });
        const KEY_BACKSLASH = 220;
        const KEY_ENTER = 13;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const KEY_ESCAPE = 27;
        const captureBackSlash = (code, state) => {
            const isBackSlash = code === KEY_BACKSLASH;
            if (isBackSlash) {
                state.active = true;
            }
            return state;
        };
        function createControlByType(type, name, parentType) {
            switch(type) {
                case 's':
                case 'n':
                case 'b': {
                    const control = document.createElement('input');
                    control.name = name;
                    control.type = atomicInputTypeMap[type];
                    control.dataset.type = type;
                    return control;
                }
                case 'l': {
                    const control = document.createElement('fieldset', { is: 'x-list' });
                    control.name = name;
                    control.tabIndex = 0;
                    control.dataset.type = type;
                    // FIXME is this nesting correct?
                    const field = createControlByType('s', `${name}[0]`);
                    control.appendChild(field);
                    return control;
                }
                case 'm': {
                    const control = document.createElement('fieldset', { is: 'x-map' });
                    control.name = name;
                    control.tabIndex = 0;
                    control.dataset.type = type;
                    control.controlCount = 1;
                    // FIXME is this nesting correct?
                    const field = createControlByType('s', `${name}[field1]`);
                    control.appendChild(field);
                    return control;
                }
            }
        }
        const jumpState = {selected: void 0};
        function coreChangeHandler(evt) {
            if(evt.target.name === 'active') {
                // if this was triggered by inactivating
                if(jumpState.selected) {
                    coreBlurHandler();
                }
            } else {
                evt.preventDefault();
                core.value = {
                    ...core.value,
                    active: false
                };
                const {selected} = jumpState;
                cleanCore();
                emitCoreChange(core.value, selected);
            }
        }
        function emitCoreChange({type}, selected) {
            const parent = selected.parentElement;
            const parentType = parent.dataset.type;
            const state = parent.value;
            if(type === '-') {
                if(Object.keys(state).length === 1) {
                    return alert('Can not remove this control as it is the only one in this parent');
                }
                const next = selected.nextElementSibling || selected.previousElementSibling;
                next && next.focus();
                selected.remove();
            } else if(type === ',') {
                // append new parent control
                let name;
                if(parentType === 'm') {
                    if(!parent.controlCount) parent.controlCount = parent.elements.length;
                    parent.controlCount++;
                    const key = 'field' + parent.controlCount;
                    name = parent.isSameNode(selected.form) ? key : `${parent.name}[${key}]`;
                } else if(parentType === 'l') {
                    // FIXME rename all children
                    const index = Array.from(parent.elements).filter(c => c.parentElement.isSameNode(parent)).length;
                    name = parent.isSameNode(selected.form) ? key : `${parent.name}[${index}]`;
                }
                const control = createControlByType('s', name, parentType);
                parent.insertBefore(control, selected.nextSibling);
                control.focus();
            } else {
                if(selected.value && !confirm('Are you sure want to change the type of this control? The value will be discarded')) {
                    return;
                }
                console.log(`change type from ${selected.type} to ${type} in parent ${parentType}`);
                //if(parentType === 'm') {
                    const control = createControlByType(type, selected.name, parentType);
                    parent.insertBefore(control, selected);
                    selected.remove();
                    if(type === 'l') {
                        console.log(control.elements)
                        control.elements[0].focus();
                    } else {
                        control.focus();
                    }
                //}
            }
        }
        function coreSubmitHandler(evt) {
            
        }
        function cleanCore() {
            core.removeEventListener("keydown", coreKeyDownHandler);
            //core.removeEventListener("focusout", coreBlurHandler);
            //core.removeEventListener("submit", coreSubmitHandler);
            main.addEventListener("keydown", mainKeyDownHandler);
            jumpState.selected.focus();
            jumpState.selected = void 0;
        }
        function coreBlurHandler(evt) {
            core.value = {
                type: jumpState.selected.dataset.type,
                active: false
            };
            cleanCore();
        }
        function coreKeyDownHandler(evt) {
            const code = evt.which;
            const controls = Array.from(this.elements);
            const isEnter = code === KEY_ENTER;
            const isCancelKey = code === KEY_ESCAPE || code === KEY_TAB || code === KEY_BACKSLASH;
            if(isCancelKey || isEnter) {
                if(isEnter) {
                    coreChangeHandler(evt);
                } else {
                    coreBlurHandler(evt);
                }
            } else {
                const isDelete = code === KEY_DELETE;
                const key = isDelete ? '-' : evt.key;
                const keyBound = controls.find(c => c.dataset.key === key);
                if(keyBound) {
                    keyBound.checked = true;
                    keyBound.focus();
                    // update immediately
                    coreChangeHandler(evt);
                }
            }
        }
        function mainKeyDownHandler(evt) {
            const state = captureBackSlash(evt.which, core.value);
            const selected = document.activeElement;
            if (state.active) {
                evt.preventDefault();
                jumpState.selected = selected;
                // TODO infer type from control (until we have custom controls)
                const type = selected.dataset.type;
                const typeControl = Array.from(core.elements).find(elm => elm.name === 'type' && elm.value === type);
                if(!typeControl) {
                    throw new TypeError('Could not find control for type ' + type);
                }
                core.value = {
                    active: true,
                    type,
                }
                typeControl.focus();
                main.removeEventListener("keydown", mainKeyDownHandler);
                //core.addEventListener("focusout", coreBlurHandler);
                //core.addEventListener("submit", coreSubmitHandler);
                core.addEventListener("change", coreChangeHandler);
                core.addEventListener("keydown", coreKeyDownHandler);
            }
        }
        main.addEventListener("keydown", mainKeyDownHandler);
    </script>
</body>

</html>